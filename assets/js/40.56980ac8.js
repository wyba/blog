(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{524:function(a,s,t){"use strict";t.r(s);var e=t(21),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("blockquote",[t("p",[a._v("搞起吧")])]),a._v(" "),t("h2",{attrs:{id:"反射简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反射简介"}},[a._v("#")]),a._v(" 反射简介")]),a._v(" "),t("h3",{attrs:{id:"一、什么是反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是反射"}},[a._v("#")]),a._v(" 一、什么是反射：")]),a._v(" "),t("p",[a._v("（1）Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。")]),a._v(" "),t("p",[a._v("（2）Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。")]),a._v(" "),t("p",[a._v("指在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法,对于任意一个对象,都能调用它的任意一个方法.这种动态获取信息,以及动态调用对象方法的功能叫java语言的反射机制.")]),a._v(" "),t("h3",{attrs:{id:"二、反射机制的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、反射机制的应用"}},[a._v("#")]),a._v(" 二、反射机制的应用")]),a._v(" "),t("p",[a._v("生成动态代理,面向切片编程(在调用方法的前后各加栈帧).")]),a._v(" "),t("h3",{attrs:{id:"三、反射机制的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、反射机制的原理"}},[a._v("#")]),a._v(" "),t("strong",[a._v("三、反射机制的原理:")])]),a._v(" "),t("p",[a._v("Class对象的由来是将.class文件读入内存，并为之创建一个Class对象。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20201031013312441.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"四-反射的基本使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-反射的基本使用"}},[a._v("#")]),a._v(" 四：反射的基本使用：")]),a._v(" "),t("h4",{attrs:{id:"_1、获得class-主要有三种方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、获得class-主要有三种方法"}},[a._v("#")]),a._v(" "),t("strong",[a._v("1、获得Class：主要有三种方法：")])]),a._v(" "),t("p",[a._v("（1）Object--\x3egetClass")]),a._v(" "),t("p",[a._v("（2）任何数据类型（包括基本的数据类型）都有一个“静态”的class属性")]),a._v(" "),t("p",[a._v("（3）通过class类的静态方法：forName(String className)（最常用）")]),a._v(" "),t("h4",{attrs:{id:"_2、判断是否为某个类的示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、判断是否为某个类的示例"}},[a._v("#")]),a._v(" "),t("strong",[a._v("2、判断是否为某个类的示例：")])]),a._v(" "),t("p",[a._v("一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("isInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h4",{attrs:{id:"_3、创建实例-通过反射来生成对象主要有两种方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、创建实例-通过反射来生成对象主要有两种方法"}},[a._v("#")]),a._v(" "),t("strong",[a._v("3、创建实例：通过反射来生成对象主要有两种方法：")])]),a._v(" "),t("p",[a._v("（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" c "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" str "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" c"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("newInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//获取String的Class对象\nClass<?> str = String.class;\n//通过Class对象获取指定的Constructor构造器对象\nConstructor constructor=c.getConstructor(String.class);\n//根据构造器创建实例：\nObject obj = constructor.newInstance(“hello reflection”);\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h4",{attrs:{id:"_4、通过反射获取构造方法并使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、通过反射获取构造方法并使用"}},[a._v("#")]),a._v(" "),t("strong",[a._v("4、通过反射获取构造方法并使用：")])]),a._v(" "),t("p",[a._v('（1）批量获取的方法：\npublic Constructor[] getConstructors()：所有"公有的"构造方法\npublic Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)')]),a._v(" "),t("p",[a._v('（2）单个获取的方法，并调用：\npublic Constructor getConstructor(Class... parameterTypes):获取单个的"公有的"构造方法：\npublic Constructor getDeclaredConstructor(Class... parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有；')]),a._v(" "),t("p",[a._v("（3） 调用构造方法：")]),a._v(" "),t("p",[a._v("Constructor--\x3enewInstance(Object... initargs)")]),a._v(" "),t("p",[a._v("newInstance是 Constructor类的方法（管理构造函数的类）")]),a._v(" "),t("p",[a._v("api的解释为：newInstance(Object... initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。")]),a._v(" "),t("p",[a._v("它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象，并为之调用。")]),a._v(" "),t("h2",{attrs:{id:"面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[a._v("#")]),a._v(" 面试题")]),a._v(" "),t("h3",{attrs:{id:"_1-谈谈你对-反射的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-谈谈你对-反射的理解"}},[a._v("#")]),a._v(" 1 谈谈你对[反射的理解")]),a._v(" "),t("p",[a._v("Java 中 的 反 射 首 先 是 能 够 获 取 到 Java 中 要 反 射 类 的 字 节 码 ， 获 取 字 节 码 有 三 种 方 法 ：")]),a._v(" "),t("p",[a._v("Class.forName(className)\n类名.class\nthis.getClass()。")]),a._v(" "),t("p",[a._v("然后将字节码中的方法，变量，构造函数等映射成相应的 Method、Filed、Constructor 等类，这些类提供了丰富的方法可以被我们所使用。")]),a._v(" "),t("h3",{attrs:{id:"_2-java反射api有几类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-java反射api有几类"}},[a._v("#")]),a._v(" 2 Java反射API有几类")]),a._v(" "),t("p",[a._v("反射 API 用来生成 JVM 中的类、接口或则对象的信息。")]),a._v(" "),t("p",[a._v("Class 类：反射的核心类，可以获取类的属性，方法等信息。\nField 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。\nMethod 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。\nConstructor 类：Java.lang.reflec 包中的类，表示类的构造方法。")]),a._v(" "),t("h3",{attrs:{id:"_3-java反射创建对象效率高还是通过new创建对象的效率高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-java反射创建对象效率高还是通过new创建对象的效率高"}},[a._v("#")]),a._v(" 3 java反射创建对象效率高还是通过new创建对象的效率高")]),a._v(" "),t("p",[a._v("通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低。")]),a._v(" "),t("h3",{attrs:{id:"_4-实例化对象的方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-实例化对象的方式"}},[a._v("#")]),a._v(" 4 实例化对象的方式")]),a._v(" "),t("p",[a._v("Java中创建（实例化）对象的五种方式")]),a._v(" "),t("p",[a._v("（1）用new语句创建对象，这是最常见的创建对象的方法。")]),a._v(" "),t("p",[a._v("（2）通过工厂方法返回对象，如：String str = String.valueOf(23);")]),a._v(" "),t("p",[a._v("（3）运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。如：Object obj = Class.forName(“java.lang.Object”).newInstance();")]),a._v(" "),t("p",[a._v("（4）调用对象的clone()方法。")]),a._v(" "),t("p",[a._v("（5）通过I/O流（包括反序列化），如运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法")]),a._v(" "),t("h3",{attrs:{id:"_5-哪里用到反射机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-哪里用到反射机制"}},[a._v("#")]),a._v(" 5 哪里用到反射机制")]),a._v(" "),t("ol",[t("li",[a._v("JDBC中，利用反射动态加载了数据库驱动程序。")]),a._v(" "),t("li",[a._v("Web服务器中利用反射调用了Sevlet的服务方法。")]),a._v(" "),t("li",[a._v("Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。")]),a._v(" "),t("li",[a._v("很多框架都用到反射机制，注入属性，调用方法，如Spring。")])]),a._v(" "),t("h3",{attrs:{id:"_6-反射机制的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-反射机制的优缺点"}},[a._v("#")]),a._v(" 6 反射机制的优缺点")]),a._v(" "),t("p",[t("strong",[a._v("优点")]),a._v("：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。")]),a._v(" "),t("p",[t("strong",[a._v("缺点")]),a._v("：对性能有影响，这类操作总是慢于直接执行java代码")]),a._v(" "),t("h3",{attrs:{id:"_7在android中的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7在android中的应用"}},[a._v("#")]),a._v(" 7在Android中的应用")]),a._v(" "),t("p",[a._v("谷歌虽然为开发者提供了众多api接口，但是对于一些个别情况这些api还是不够的，反射机制就是谷歌提供了另外一种扩充api接口的方式，只能在sdk源码中能够看到拥有@hide的标签，那么就可以使用反射来为我们使用，它作用于程序运行时状态。")]),a._v(" "),t("ul",[t("li",[a._v("1，必须要有@hide修饰，否则无法反射")]),a._v(" "),t("li",[a._v("2，getField,getMethod只能反射public类型的数据，getDeclaredField，getDeclaredMethods可以反射任何类型的数据。")]),a._v(" "),t("li",[a._v("3，getField,getMethod可以反射父类的数据，而getDeclaredField，getDeclaredMethods只能获取当前类的数据。")]),a._v(" "),t("li",[a._v("4，对于private static final 这种方法或者变量反射时无法调用，需要在下面执行\nmethod.setAccessible(true);")])])])}),[],!1,null,null,null);s.default=r.exports}}]);