(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{505:function(v,_,t){"use strict";t.r(_);var a=t(21),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("blockquote",[t("p",[v._v("说明：性能优化，老生常淡了")])]),v._v(" "),t("p",[v._v("安卓开发大军浩浩荡荡，经过近十年的发展，Android技术优化日异月新，如今Android 9.0 已经发布，Android系统性能也已经非常流畅，可以在体验上完全媲美iOS。\n但是，到了各大厂商手里，改源码、自定义系统，使得Android原生系统变得鱼龙混杂，然后到了不同层次的开发工程师手里，因为技术水平的参差不齐，即使很多手机在跑分软件性能非常高，打开应用依然存在卡顿现象。另外，随着产品内容迭代，功能越来越复杂，UI页面也越来越丰富，也成为流畅运行的一种阻碍。综上所述，对APP进行性能优化已成为开发者该有的一种综合素质，也是开发者能够完成高质量应用程序作品的保证。")]),v._v(" "),t("p",[v._v("在Android应用优化方面，我们主要从以下4个方面进行优化：")]),v._v(" "),t("p",[v._v("1.稳定（内存溢出、崩溃）\n2.流畅（卡顿）\n3.耗损（耗电、流量、网络）\n4.安装包（APK瘦身）")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/4118241-fbeaa6abd09fecd4.png",alt:"img"}})]),v._v(" "),t("h2",{attrs:{id:"一、内存优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、内存优化"}},[v._v("#")]),v._v(" 一、内存优化")]),v._v(" "),t("p",[v._v("在Android应用开发中，影响稳定性的原因很多，比如内存使用不合理、代码异常场景考虑不周全、代码逻辑不合理等，都会对应用的稳定性造成影响。\n其中最常见的两个场景是：Crash 和 ANR，这两个错误将会使得程序无法使用。所以做好Crash监控，把崩溃信息、异常信息收集记录起来，以便后续分析；合理使用主线程处理业务，不要在主线程中做耗时操作，防止ANR程序无响应发生。")]),v._v(" "),t("p",[v._v("通俗来讲，内存泄露不仅仅会造成应用内存占用过大，还会导致应用卡顿，造成不好的用户体验。")]),v._v(" "),t("p",[v._v("内存抖动\n短时间内创建了大量对象同时又被快速释放。比如在一个大循环里去不断创建对象，会导致频繁gc;")]),v._v(" "),t("p",[v._v("内存泄漏\n内存泄漏会导致可用内存逐渐变少，而且内存碎片加多，这也会增多gc次数，甚至可能发生OOM")]),v._v(" "),t("p",[v._v("一次申请太大内存空间\n由于内存碎片的存在，就算内存本身足够，但由于碎片导致无法找到一块大空间，这也会触发gc；")]),v._v(" "),t("p",[v._v("内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了没来就不多的内存空间。")]),v._v(" "),t("p",[v._v("那么什么情况下会出现这样的对象呢？ 基本可以分为以下四大类：\n1、集合类泄漏\n2、单例/静态变量造成的内存泄漏\n3、匿名内部类/非静态内部类\n4、资源未关闭造成的内存泄漏")]),v._v(" "),t("p",[v._v("集合类添加元素后，仍引用着集合元素对象，导致该集合中的元素对象无法被回收，从而导致内存泄露。")]),v._v(" "),t("p",[v._v("当我们在Activity里面使用这个的时候，把我们Acitivty的context传进去，那么，这个单例就持有这个Activity的引用，当这个Activity没有用了，需要销毁的时候，因为这个单例还持有Activity的引用，所以无法GC回收，所以就出现了内存泄漏，也就是生命周期长的持有了生命周期短的引用，造成了内存泄漏。")]),v._v(" "),t("p",[v._v("非静态内部类他会持有他外部类的引用，从图我们可以看到非静态内部类的生命周期可能比外部类更长，这就是二楼的情况一致了，如果非静态内部类的周明周期长于外部类，在加上自动持有外部类的强引用，我的乖乖，想不泄漏都难啊。")]),v._v(" "),t("p",[v._v("引用分为强引用，软引用，弱引用，虚引用，强度依次递减。")]),v._v(" "),t("ul",[t("li",[v._v("强引用\n我们平时不做特殊处理的一般都是强引用，如果一个对象具有强引用，GC宁可OOM也绝不会回收它。看出多强硬了吧。")]),v._v(" "),t("li",[v._v("软引用(SoftReference)\n如果内存空间足够，GC就不会回收它，如果内存空间不足了，就会回收这些对象的内存。")]),v._v(" "),t("li",[v._v("弱引用（WeakReference）\n弱引用要比软引用,更弱一个级别，内存不够要回收他，GC的时候不管内存够不够也要回收他，简直是弱的一匹。不过GC是一个优先级很低的线程，也不是太频繁进行，所以弱引用的生活还过得去，没那么提心吊胆。")]),v._v(" "),t("li",[v._v("虚引用\n用的甚少，我没有用过，如果想了解的朋友，可以自行谷歌百度。")])]),v._v(" "),t("p",[v._v("所以我们用弱引用来修饰Activity，这样GC的时候，该回收的也就回收了，不会再有内存泄漏了。很完美。")]),v._v(" "),t("p",[v._v("资源未关闭造成的内存泄漏")]),v._v(" "),t("ul",[t("li",[v._v("网络、文件等流忘记关闭")]),v._v(" "),t("li",[v._v("手动注册广播时，退出时忘记 unregisterReceiver()")]),v._v(" "),t("li",[v._v("Service 执行完后忘记 stopSelf()")]),v._v(" "),t("li",[v._v("EventBus 等观察者模式的框架忘记手动解除注册")])]),v._v(" "),t("h2",{attrs:{id:"二、交互优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、交互优化"}},[v._v("#")]),v._v(" 二、交互优化")]),v._v(" "),t("p",[v._v("交互是与用户体验最直接的方面，交互场景大概可以分为四个部分：UI 绘制、应用启动、页面跳转、事件响应。对于上面四个方面，大致可以从以下两个方面来进行优化：")]),v._v(" "),t("p",[v._v("界面绘制：主要原因是绘制的层级深、页面复杂、刷新不合理，由于这些原因导致卡顿的场景更多出现在 UI 和启动后的初始界面以及跳转到页面的绘制上。")]),v._v(" "),t("p",[v._v("数据处理：导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，一是数据在处理 UI 线程，二是数据处理占用 CPU 高，导致主线程拿不到时间片，三是内存增加导致 GC 频繁，从而引起卡顿。")]),v._v(" "),t("p",[v._v("我们知道，Android的绘制需要经过onMeasure、onLayout、onDraw等几个步骤，所以布局的层级越深、元素越多、耗时也就越长。还有就是Android 系统每隔 16ms 发出 VSYNC 信号，触发对 UI 进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的 60FPS。如果某个操作花费的时间是 24ms ，系统在得到 VSYNC 信号时就无法正常进行正常渲染，这样就发生了丢帧现象。")]),v._v(" "),t("p",[v._v("之所以出现卡顿现象，是因为有两个原因：")]),v._v(" "),t("p",[v._v("绘制任务太重，绘制一帧内容耗时太长")]),v._v(" "),t("p",[v._v("主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧")]),v._v(" "),t("h3",{attrs:{id:"布局优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布局优化"}},[v._v("#")]),v._v(" 布局优化")]),v._v(" "),t("p",[v._v("在Android种系统对View进行测量、布局和绘制时，都是通过对View数的遍历来进行操作的。如果一个View数的高度太高就会严重影响测量、布局和绘制的速度。Google也在其API文档中建议View高度不宜哦过10层。现在版本种Google使用RelativeLayout替代LineraLayout作为默认根布局，目的就是降低LineraLayout嵌套产生布局树的高度，从而提高UI渲染的效率。\n在布局优化方面，我们可以从以下几个方面进行优化：")]),v._v(" "),t("p",[v._v("布局复用，使用"),t("include",[v._v("标签重用layout；\n提高显示速度，使用"),t("ViewStub",[v._v("延迟View加载；\n减少层级，使用"),t("merge",[v._v("标签替换父级布局；\n注意使用wrap_content，会增加measure计算成本；\n删除控件中无用属性；")])],1)],1)],1),v._v(" "),t("p",[v._v("复杂界面可选择ConstraintLayout，可有效减少层级")]),v._v(" "),t("p",[v._v("尽量减少不必要的嵌套")]),v._v(" "),t("p",[v._v("能用LinearLayout和FrameLayout，就不要用RelativeLayout，因为RelativeLayout控件相对比较复杂，测绘也想要耗时。")]),v._v(" "),t("h3",{attrs:{id:"渲染优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染优化"}},[v._v("#")]),v._v(" 渲染优化")]),v._v(" "),t("p",[v._v("过度绘制是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构中，如果不可见的 UI 也在做绘制的操作，就会导致某些像素区域被绘制了多次，从而浪费了多余的 CPU 以及 GPU 资源。我们可以通过开启手机的过渡绘制功能来检测页面是否被过度绘制。")]),v._v(" "),t("p",[v._v("为了避免过度绘制，我们可以从以下几个方面进行优化：")]),v._v(" "),t("p",[v._v("布局上的优化，移除 XML 中非必须的背景，移除 Window 默认的背景、按需显示占位背景图片。\n自定义View优化，使用 canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。")]),v._v(" "),t("ul",[t("li",[v._v("onDraw中不要创建新的局部对象")]),v._v(" "),t("li",[v._v("onDraw方法中不要做耗时的任务")])]),v._v(" "),t("h3",{attrs:{id:"启动优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动优化"}},[v._v("#")]),v._v(" 启动优化")]),v._v(" "),t("p",[v._v("app启动分为冷启动（Cold start）、热启动（Hot start）和温启动（Warm start）三种。")]),v._v(" "),t("p",[v._v("应用一般都有闪屏页，优化闪屏页的 UI 布局，可以通过 Profile GPU Rendering 检测丢帧情况。")]),v._v(" "),t("p",[v._v("也可以通过启动加载逻辑优化。可以采用分布加载、异步加载、延期加载策略来提高应用启动速度。")]),v._v(" "),t("p",[v._v("数据准备。数据初始化分析，加载数据可以考虑用线程初始化等策略。")]),v._v(" "),t("p",[v._v("1、利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；\n2、避免在启动时做密集沉重的初始化（Heavy app initialization）；\n3、避免I/O操作、反序列化、网络操作、布局嵌套等。")]),v._v(" "),t("h3",{attrs:{id:"刷新优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#刷新优化"}},[v._v("#")]),v._v(" 刷新优化")]),v._v(" "),t("p",[v._v("item 刷新\n对于列表的中的item的操作，比如对item点赞，此时不应该让整个列表刷新，而是应该只刷新这个item.")]),v._v(" "),t("p",[v._v("复杂Activity刷新\n对于较为复杂的页面，个人建议不要写在一个activity中，建议使用几个fragment进行组装，这样一来，module的变更可以只刷新某一个具体的fragment，而不用整个页面都走刷新逻辑。但是问题来了，fragment之间如何共享数据呢？好，看我怎么操作。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/4118241-90e3e6642b7ea66f.png",alt:"img"}})]),v._v(" "),t("h2",{attrs:{id:"四、apk瘦身"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、apk瘦身"}},[v._v("#")]),v._v(" 四、APK瘦身")]),v._v(" "),t("p",[v._v("应用安装包大小对应用使用没有影响，但应用的安装包越大，用户下载的门槛越高，特别是在移动网络情况下，用户在下载应用时，对安装包大小的要求更高，因此，减小安装包大小可以让更多用户愿意下载和体验产品。")]),v._v(" "),t("p",[v._v("在Android Studio工具栏里，打开build–>Analyze APK, 选择要分析的APK包 ，可以看到apk的相关信息，如下所示：\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20190618213956249.png",alt:"在这里插入图片描述"}}),v._v("\nAndroid的apk主要有以下信息构成：")]),v._v(" "),t("p",[v._v("assets文件夹。存放一些配置文件、资源文件，assets不会自动生成对应的 ID，而是通过 AssetManager 类的接口获取。")]),v._v(" "),t("p",[v._v("res。res 是 resource 的缩写，这个目录存放资源文件，会自动生成对应的 ID 并映射到 .R 文件中，访问直接使用资源ID。")]),v._v(" "),t("p",[v._v("META-INF。保存应用的签名信息，签名信息可以验证 APK 文件的完整性。")]),v._v(" "),t("p",[v._v("AndroidManifest.xml。这个文件用来描述 Android 应用的配置信息，一些组件的注册信息、可使用权限等。")]),v._v(" "),t("p",[v._v("classes.dex。Dalvik 字节码程序，让 Dalvik 虚拟机可执行，一般情况下，Android 应用在打包时通过Android SDK 中的 dx 工具将 Java 字节码转换为 Dalvik 字节码。")]),v._v(" "),t("p",[v._v("resources.arsc。记录着资源文件和资源 ID 之间的映射关系，用来根据资源 ID 寻找资源。")]),v._v(" "),t("p",[v._v("基于上面的组成部分，那么优化也可以从以下几个方面着手：")]),v._v(" "),t("p",[v._v("代码混淆。使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。")]),v._v(" "),t("p",[v._v("资源优化。比如使用 Android Lint 删除冗余资源，资源文件最少化等。")]),v._v(" "),t("p",[v._v("图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数等。")]),v._v(" "),t("p",[v._v("避免重复功能的库，使用 WebP图片格式等。")]),v._v(" "),t("p",[v._v("插件化，比如功能模块放在服务器上，按需下载，可以减少安装包大小。")])])}),[],!1,null,null,null);_.default=e.exports}}]);