(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{514:function(a,p,_){"use strict";_.r(p);var v=_(21),i=Object(v.a)({},(function(){var a=this,p=a.$createElement,_=a._self._c||p;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"一、drawable和mipmap的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、drawable和mipmap的区别是什么"}},[a._v("#")]),a._v(" 一、drawable和mipmap的区别是什么？")]),a._v(" "),_("p",[a._v("应用图标的图片资源存放在mipmap系列文件夹中，而其余图片存放在drawable系列文件夹中")]),a._v(" "),_("p",[a._v("1、mipmap纹理映射技术会将资源缩放到设备分辨率大小，drawable会将资源缩放到设备匹配的倍数大小")]),a._v(" "),_("p",[a._v("2、官方推荐开发者将位图等资源放在对应dpi的drawable/下，而不是放在mipmap/下。这样各种dpi可直接找到对应资源，减少了mipmap精确适配时需要缩放计算，也不会因为图片缩放导致显示问题")]),a._v(" "),_("p",[a._v("3、高密度系统的设备去使用低密度目录下的图片资源时，会将图片长宽自动放大以去适应高密度的精度，当然图片占用的内存会更大。")]),a._v(" "),_("h2",{attrs:{id:"二、bitmap内存占用怎么算的-如加载一张1080-1920的图片-内存占用多少"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、bitmap内存占用怎么算的-如加载一张1080-1920的图片-内存占用多少"}},[a._v("#")]),a._v(" 二、Bitmap内存占用怎么算的？如加载一张1080*1920的图片，内存占用多少？")]),a._v(" "),_("p",[a._v("Bitmap的内存占用的大小是通过：")]),a._v(" "),_("p",[a._v("宽 * 高 * 单位像素所占字节 //1080 * 1920 * 单位像素所占字节(ARGB值不同，占用字节不同)")]),a._v(" "),_("p",[a._v("Bitmap.Config中有四种不同的ARGB： ALPHA_8、RGB_565、ARGB_4444、ARGB_8888")]),a._v(" "),_("p",[a._v("ALPHA_8：每个像素占8位，没有色彩，只有透明度A-8 即10801920(8/8/1024/1024)= 1.98M")]),a._v(" "),_("p",[a._v("RGB_565：每个像素每个像素占16位，没有透明度 5+6+5 = 16 即10801920(16/8/1024/1024) = 3.96M")]),a._v(" "),_("p",[a._v("ARGB_4444：每个像素占16位，4+4+4+4 = 16 即 10801920(16/8/1024/1024) = 3.96M")]),a._v(" "),_("p",[a._v("ARGB_8888：每个像素占32位，8+8+8+8 = 32 即 10801920(32/8/1024/1024) = 7.92M")]),a._v(" "),_("p",[a._v("注意：加载图片所在内存还和图片放置的目录有关系：放在mdpi、xhdpi之下是不一样的。")]),a._v(" "),_("p",[a._v("在320dpi(xhdpi)设备上运行，当图片放置在xhdpi中时，获取图片宽高依然是352 *  484。当图片放置在mdpi中时，获取宽高是 704 *  968，设备是320dpi的设备，当放置在mdpi时，系统认为图片需要放大，xhdpi是mdpi的两倍，所以获取bitmap的宽高放大了两倍。")]),a._v(" "),_("p",[a._v("当图片都放置在xhdpi时，使用320dpi(xhdpi)设备获取图片宽高是352 * 484，当使用480dpi(xxhdpi)设备获取图片宽高位 528 * 726，即在480dpi设备上时，xhdpi下的图片都认为要被放大480/320(3/2)倍。")]),a._v(" "),_("p",[a._v("结论：")]),a._v(" "),_("p",[a._v("1、在同一个设备上，图片放在依次放在由低到高的分辨率目录中(mdpi~xxxhdpi)，图片的 Bitmap 内存的大小不断减小。")]),a._v(" "),_("p",[a._v("2、在同一个分辨率目录中，依次运行在由低到高的分辨率设备上，图片的 Bitmap 的大小不断增加。")]),a._v(" "),_("p",[a._v("所以：如果只使用一套图片时，尽量把图片放到最大分辨率目录中")]),a._v(" "),_("h2",{attrs:{id:"三、系统如何选择drawable进行加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、系统如何选择drawable进行加载"}},[a._v("#")]),a._v(" 三、系统如何选择drawable进行加载")]),a._v(" "),_("p",[a._v("Android系统中，在加载图片时，会根据系统自身的dpi设备大小优先匹配最近的一个drawable目录，如果当前目录没有找到，则向上查找，一直找到nodpi，如果都没有找到则向下开始查找(肯定能找到，如果找不到编译器就报错了)。如：设备hdpi 则优先找drawable-hdpi目录下的资源，如果没有则向上  xhdpi、xxhdpi、xxxhdpi、nodpi，都没有的话则开始查找mdpi...")]),a._v(" "),_("h2",{attrs:{id:"四、bitmap导致的oom如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、bitmap导致的oom如何解决"}},[a._v("#")]),a._v(" 四、Bitmap导致的OOM如何解决")]),a._v(" "),_("p",[a._v("Android加载大图时极容易产生OOM，采用压缩算法、缓存、软引用、及时对不再使用的bitmap对象recycle释放等方式解决。")]),a._v(" "),_("p",[a._v("通常会有四种压缩方案：")]),a._v(" "),_("p",[a._v("1、质量压缩：")]),a._v(" "),_("p",[a._v("质量压缩通过减少图片色彩度，不会减少图片像素及宽高，所以不会减少加载到内存中所占的内存大小，只会减少图片所占磁盘的存储大小，是一种有损压缩。")]),a._v(" "),_("p",[a._v("2、采样率压缩：")]),a._v(" "),_("p",[a._v("采样率压缩其原理是缩放 bitmap 的尺寸，采样率inSampleSize为1时不变，2时宽高都变为原来的1/2，所占用内存大小就会变为原来的1/4，以此类推。")]),a._v(" "),_("p",[a._v("由于 inSampleSize 只能为 2 的整次幂，所以无法精确控制大小")]),a._v(" "),_("p",[a._v("3、缩放压缩：Matrix矩阵")]),a._v(" "),_("p",[a._v("缩放压缩使用的是通过矩阵对图片进行缩放，缩放后图片的 宽度、高度以及占用的内存都会改变。")]),a._v(" "),_("p",[a._v("4、色彩模式压缩：Options.inPreferredConfig = Bitmap.Config.XXXX")]),a._v(" "),_("p",[a._v("色彩模式压缩后图片的宽高不会产生变化，由于图片的存储格式改变，与 ARGB_8888 相比，每个像素的占用的字节由 8 变为 4 ， 所以图片占用的内存也为原来的一半。")]),a._v(" "),_("p",[a._v("内存缓存：Android SDK中提供了一个LruCache，用于内存缓存。")]),a._v(" "),_("p",[a._v("磁盘缓存：Android SDK中不提供磁盘缓存的类，但google官方推荐的一个叫DiskLruCache算法。")]),a._v(" "),_("h2",{attrs:{id:"五、lrucache原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、lrucache原理"}},[a._v("#")]),a._v(" 五、LRUCache原理")]),a._v(" "),_("p",[a._v("因此LRU(Least Recently  Used)缓存算法便应运而生，LRU是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。")]),a._v(" "),_("p",[a._v("采用LRU算法的缓存有两种：LrhCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。")]),a._v(" "),_("p",[a._v("LruCache是Android 3.1所提供的一个缓存类，所以在Android中可以直接使用LruCache实现内存缓存")]),a._v(" "),_("p",[a._v("LruCache是个泛型类，主要算法原理是把最近使用的对象用强引用（即我们平常使用的对象引用方式）存储在 LinkedHashMap 中。当缓存满时，把最近最少使用的对象从内存中移除，并提供了get和put方法来完成缓存的获取和添加操作。")]),a._v(" "),_("h3",{attrs:{id:"lrucache的使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lrucache的使用"}},[a._v("#")]),a._v(" LruCache的使用")]),a._v(" "),_("p",[a._v("①设置LruCache缓存的大小，一般为当前进程可用容量的1/8。")]),a._v(" "),_("p",[a._v("②重写sizeOf方法，计算出要缓存的每张图片的大小。")]),a._v(" "),_("h3",{attrs:{id:"lrucache的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lrucache的实现原理"}},[a._v("#")]),a._v(" LruCache的实现原理")]),a._v(" "),_("p",[a._v("LruCache的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队尾，即将被淘汰。而最近访问的对象将放在队头，最后被淘汰。")]),a._v(" "),_("p",[a._v("而LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序，使得LinkedHashMap中的<key,value>对按照一定顺序排列起来。")]),a._v(" "),_("p",[_("strong",[a._v("由此可见LruCache中维护了一个集合LinkedHashMap，该LinkedHashMap是以访问顺序排序的。当调用put()方法时，就会在结合中添加元素，并调用trimToSize()判断缓存是否已满，如果满了就用LinkedHashMap的迭代器删除队尾元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队头。")])]),a._v(" "),_("h2",{attrs:{id:"六、disklrucache"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、disklrucache"}},[a._v("#")]),a._v(" 六、DiskLruCache")]),a._v(" "),_("p",[a._v("LruCache只是管理了内存中图片的存储与释放，如果图片从内存中被移除的话，那么又需要从网络上重新加载一次图片，这显然非常耗时。对此，Google又提供了一套硬盘缓存的解决方案：DiskLruCache(非Google官方编写，但获得官方认证)。")]),a._v(" "),_("p",[a._v("DiskLruCache最大的特点就是持久化存储，所有的缓存以文件的形式存在。在用户进入APP时，它根据日志文件将DiskLruCache恢复到用户上次退出时的情况，日志文件journal保存每个文件的下载、访问和移除的信息，在恢复缓存时逐行读取日志并检查文件来恢复缓存。")])])}),[],!1,null,null,null);p.default=i.exports}}]);