(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{517:function(t,e,s){"use strict";s.r(e);var r=s(21),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("总结")])]),t._v(" "),s("p",[t._v("EventBus的出现完美的解决了多个线程和多个activity、fragment之间的通信问题，下面我们来讲解一下具体的实现原理：")]),t._v(" "),s("h2",{attrs:{id:"_1、实例化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、实例化"}},[t._v("#")]),t._v(" 1、实例化")]),t._v(" "),s("p",[t._v("EventBus使用的单例双重锁创建了实例")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200413145839229.png",alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"_2、register"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、register"}},[t._v("#")]),t._v(" 2、register")]),t._v(" "),s("p",[t._v("在看一下register()，通过反射，图中标记1方法是把当前对象的所有带@Subscribe注解的方法保存到list中，2是遍历每一个方法，取出方法的eventType，创建Subscription对象存放实体对象和方法的封装类，再将eventType与Subscription关联起来")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200413150302556.png",alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"_3、post"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、post"}},[t._v("#")]),t._v(" 3、post")]),t._v(" "),s("p",[t._v("EventBus.getDefault().post(Object event)；的post()是去将参数对象添加到队列，并判断当时所在线程，去匹配所有与这个参数相关的方法，这里参数只能有1个")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200413152512160.png",alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"_4、unregister"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、unregister"}},[t._v("#")]),t._v(" 4、unregister")]),t._v(" "),s("p",[t._v("EventBus.getDefault().unregister(this); 的 unregister()解绑主要就是将当前类中集合里面的方法删除掉")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200413153203437.png",alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结：")]),t._v(" "),s("p",[t._v("EventBus原理，主要是通过注解和反射实现，将方法保存在公共队列中供其调用，首先在register()的时候，通过反射把当前类的所有方法遍历，然后把带有@Subscribe注解的方法保存在队列中，在调用的时候发送post方法，与队列中的方法进行匹配，这里只匹配方法的参数，如果一样的话就掉起该方法。")])])}),[],!1,null,null,null);e.default=a.exports}}]);