(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{549:function(v,_,i){"use strict";i.r(_);var e=i(21),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("blockquote",[i("p",[v._v("说明：昨天被一个垃圾羞辱了，一个玩网络的安卓开发居然对我百般屈辱，鸟人，只会玩他们那一套，渣渣，没准备好就会各种难倒，面试真的就是个形式，走好了一切都好说，平时开发都不用的，面试噼里啪啦一堆问，狗屎。")])]),v._v(" "),i("p",[v._v("收集面试题目O(∩_∩)O哈哈~")]),v._v(" "),i("h2",{attrs:{id:"一-android面试相关"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#一-android面试相关"}},[v._v("#")]),v._v(" 一. Android面试相关")]),v._v(" "),i("h3",{attrs:{id:"_1-activity"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-activity"}},[v._v("#")]),v._v(" 1.Activity")]),v._v(" "),i("ul",[i("li",[v._v("说下Activity生命周期")]),v._v(" "),i("li",[v._v("Activity A 启动另一个Activity B 会调用哪些方法？如果B是透明主题的又或则是个DialogActivity呢")]),v._v(" "),i("li",[v._v("说下onSaveInstanceState()方法的作用 ? 何时会被调用？")]),v._v(" "),i("li",[v._v("Activity的启动流程")]),v._v(" "),i("li",[v._v("onSaveInstanceState(),onRestoreInstanceState的掉用时机")]),v._v(" "),i("li",[v._v("activity的启动模式和使用场景")]),v._v(" "),i("li",[v._v("Activity A跳转Activity B，再按返回键，生命周期执行的顺序")]),v._v(" "),i("li",[v._v("横竖屏切换,按home键,按返回键,锁屏与解锁屏幕,跳转透明Activity界面,启动一个 Theme 为 Dialog 的                                Activity，弹出Dialog时Activity的生命周期")]),v._v(" "),i("li",[v._v("onStart 和 onResume、onPause 和 onStop 的区别")]),v._v(" "),i("li",[v._v("Activity之间传递数据的方式Intent是否有大小限制，如果传递的数据量偏大，有哪些方案")]),v._v(" "),i("li",[v._v("Activity的onNewIntent()方法什么时候会执行")]),v._v(" "),i("li",[v._v("显示启动和隐式启动")]),v._v(" "),i("li",[v._v("scheme使用场景,协议格式,如何使用")]),v._v(" "),i("li",[v._v("ANR 的四种场景")]),v._v(" "),i("li",[v._v("onCreate和onRestoreInstance方法中恢复数据时的区别")]),v._v(" "),i("li",[v._v("activty间传递数据的方式")]),v._v(" "),i("li",[v._v("跨App启动Activity的方式,注意事项")]),v._v(" "),i("li",[v._v("Activity任务栈是什么")]),v._v(" "),i("li",[v._v("有哪些Activity常用的标记位Flags")]),v._v(" "),i("li",[v._v("Activity的数据是怎么保存的,进程被Kill后,保存的数据怎么恢复的")])]),v._v(" "),i("h3",{attrs:{id:"_2-service"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-service"}},[v._v("#")]),v._v(" 2.Service")]),v._v(" "),i("ul",[i("li",[v._v("service 的生命周期，两种启动方式的区别")]),v._v(" "),i("li",[v._v("Service的两种启动方式？区别在哪")]),v._v(" "),i("li",[v._v("如何保证Service不被杀死 ？")]),v._v(" "),i("li",[v._v("Service与Activity怎么实现通信")]),v._v(" "),i("li",[v._v("IntentService是什么,IntentService原理，应用场景及其与Service的区别")]),v._v(" "),i("li",[v._v("Service 的 onStartCommand 方法有几种返回值?各代表什么意思?")]),v._v(" "),i("li",[v._v("bindService和startService混合使用的生命周期以及怎么关闭")]),v._v(" "),i("li",[v._v("用过哪些系统Service ？")]),v._v(" "),i("li",[v._v("了解ActivityManagerService吗？发挥什么作用")])]),v._v(" "),i("h3",{attrs:{id:"_3-broadcastreceiver"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-broadcastreceiver"}},[v._v("#")]),v._v(" 3.BroadcastReceiver")]),v._v(" "),i("ul",[i("li",[v._v("广播的分类和使用场景")]),v._v(" "),i("li",[v._v("广播的两种注册方式的区别")]),v._v(" "),i("li",[v._v("广播发送和接收的原理")]),v._v(" "),i("li",[v._v("本地广播和全局广播的区别")])]),v._v(" "),i("h3",{attrs:{id:"_4-contentprovider"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4-contentprovider"}},[v._v("#")]),v._v(" 4.ContentProvider")]),v._v(" "),i("ul",[i("li",[v._v("什么是ContentProvider及其使用")]),v._v(" "),i("li",[v._v("ContentProvider的权限管理")]),v._v(" "),i("li",[v._v("ContentProvider,ContentResolver,ContentObserver之间的关系")]),v._v(" "),i("li",[v._v("ContentProvider的实现原理")]),v._v(" "),i("li",[v._v("ContentProvider的优点")]),v._v(" "),i("li",[v._v("Uri 是什么")])]),v._v(" "),i("h3",{attrs:{id:"_5-handler"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_5-handler"}},[v._v("#")]),v._v(" 5.Handler")]),v._v(" "),i("ul",[i("li",[v._v("Handler的实现原理")]),v._v(" "),i("li",[v._v("子线程中能不能直接new一个Handler,为什么主线程可以主线程的Looper第一次调用loop方法,什么时候,哪个类")]),v._v(" "),i("li",[v._v("Handler导致的内存泄露原因及其解决方案")]),v._v(" "),i("li",[v._v("一个线程可以有几个Handler,几个Looper,几个MessageQueue对象")]),v._v(" "),i("li",[v._v("Message对象创建的方式有哪些 & 区别？\nMessage.obtain()怎么维护消息池的")]),v._v(" "),i("li",[v._v("Handler 有哪些发送消息的方法")]),v._v(" "),i("li",[v._v("Handler的post与sendMessage的区别和应用场景")]),v._v(" "),i("li",[v._v("handler postDealy后消息队列有什么变化，假设先 postDelay 10s, 再postDelay 1s, 怎么处理这2条消息")]),v._v(" "),i("li",[v._v("MessageQueue是什么数据结构")]),v._v(" "),i("li",[v._v("Handler怎么做到的一个线程对应一个Looper，如何保证只有一个MessageQueue ThreadLocal在Handler机制中的作用")]),v._v(" "),i("li",[v._v("HandlerThread是什么 & 好处 &原理 & 使用场景")]),v._v(" "),i("li",[v._v("IdleHandler及其使用场景")]),v._v(" "),i("li",[v._v("消息屏障,同步屏障机制")]),v._v(" "),i("li",[v._v("子线程能不能更新UI")]),v._v(" "),i("li",[v._v("为什么Android系统不建议子线程访问UI")]),v._v(" "),i("li",[v._v("Android中为什么主线程不会因为Looper.loop()里的死循环卡死")]),v._v(" "),i("li",[v._v("MessageQueue#next 在没有消息的时候会阻塞，如何恢复？")]),v._v(" "),i("li",[v._v("Handler消息机制中，一个looper是如何区分多个Handler的")]),v._v(" "),i("li",[v._v("当Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理")]),v._v(" "),i("li",[v._v("处理message的时候怎么知道是去哪个callback处理的")]),v._v(" "),i("li",[v._v("Looper.quit/quitSafely的区别")]),v._v(" "),i("li",[v._v("通过Handler如何实现线程的切换")]),v._v(" "),i("li",[v._v("Handler 如何与 Looper 关联的")]),v._v(" "),i("li",[v._v("Looper 如何与 Thread 关联的")]),v._v(" "),i("li",[v._v("Looper.loop()源码")]),v._v(" "),i("li",[v._v("MessageQueue的enqueueMessage()方法如何进行线程同步的")]),v._v(" "),i("li",[v._v("MessageQueue的next()方法内部原理")]),v._v(" "),i("li",[v._v("子线程中是否可以用MainLooper去创建Handler，Looper和Handler是否一定处于一个线程")]),v._v(" "),i("li",[v._v("ANR和Handler的联系")])]),v._v(" "),i("h3",{attrs:{id:"_6-view绘制"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_6-view绘制"}},[v._v("#")]),v._v(" 6.View绘制")]),v._v(" "),i("ul",[i("li",[v._v("View绘制流程")]),v._v(" "),i("li",[v._v("MeasureSpec是什么")]),v._v(" "),i("li",[v._v("子View创建MeasureSpec创建规则是什么")]),v._v(" "),i("li",[v._v("自定义Viewwrap_content不起作用的原因")]),v._v(" "),i("li",[v._v("在Activity中获取某个View的宽高有几种方法")]),v._v(" "),i("li",[v._v("为什么onCreate获取不到View的宽高")]),v._v(" "),i("li",[v._v("View#post与Handler#post的区别")]),v._v(" "),i("li",[v._v("Android绘制和屏幕刷新机制原理")]),v._v(" "),i("li",[v._v("Choreography原理")]),v._v(" "),i("li",[v._v("什么是双缓冲")]),v._v(" "),i("li",[v._v("为什么使用SurfaceView")]),v._v(" "),i("li",[v._v("什么是SurfaceView")]),v._v(" "),i("li",[v._v("View和SurfaceView的区别")]),v._v(" "),i("li",[v._v("SurfaceView为什么可以直接子线程绘制")]),v._v(" "),i("li",[v._v("SurfaceView、TextureView、SurfaceTexture、GLSurfaceView")]),v._v(" "),i("li",[v._v("getWidth()方法和getMeasureWidth()区别")]),v._v(" "),i("li",[v._v("invalidate() 和 postInvalidate() 的区别")]),v._v(" "),i("li",[v._v("Requestlayout，onlayout，onDraw，DrawChild区别与联系")]),v._v(" "),i("li",[v._v("LinearLayout、FrameLayout 和 RelativeLayout 哪个效率高")]),v._v(" "),i("li",[v._v("LinearLayout的绘制流程")]),v._v(" "),i("li",[v._v("自定义 View 的流程和注意事项")]),v._v(" "),i("li",[v._v("自定义View如何考虑机型适配")]),v._v(" "),i("li",[v._v("自定义控件优化方案")]),v._v(" "),i("li",[v._v("invalidate怎么局部刷新")]),v._v(" "),i("li",[v._v("View加载流程（setContentView）")])]),v._v(" "),i("h3",{attrs:{id:"_7-view事件分发"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_7-view事件分发"}},[v._v("#")]),v._v(" 7.View事件分发")]),v._v(" "),i("ul",[i("li",[v._v("View事件分发机制")]),v._v(" "),i("li",[v._v("view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级")]),v._v(" "),i("li",[v._v("onTouch 和onTouchEvent 的区别")]),v._v(" "),i("li",[v._v("ACTION_CANCEL什么时候触发")]),v._v(" "),i("li",[v._v("事件是先到DecorView还是先到Window")]),v._v(" "),i("li",[v._v("点击事件被拦截，但是想传到下面的View，如何操作")]),v._v(" "),i("li",[v._v("如何解决View的事件冲突")]),v._v(" "),i("li",[v._v("在 ViewGroup 中的 onTouchEvent 中消费 ACTION_DOWN 事件，ACTION_UP事件是怎么传递")]),v._v(" "),i("li",[v._v("Activity ViewGroup和View都不消费ACTION_DOWN,那么ACTION_UP事件是怎么传递的")]),v._v(" "),i("li",[v._v("同时对父 View 和子 View 设置点击方法，优先响应哪个")]),v._v(" "),i("li",[v._v("requestDisallowInterceptTouchEvent的调用时机")])]),v._v(" "),i("h3",{attrs:{id:"_8-recycleview"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_8-recycleview"}},[v._v("#")]),v._v(" 8.RecycleView")]),v._v(" "),i("ul",[i("li",[v._v("RecyclerView的多级缓存机制,每一级缓存具体作用是什么,分别在什么场景下会用到哪些缓存")]),v._v(" "),i("li",[v._v("RecyclerView的滑动回收复用机制")]),v._v(" "),i("li",[v._v("RecyclerView的刷新回收复用机制")]),v._v(" "),i("li",[v._v("RecyclerView 为什么要预布局")]),v._v(" "),i("li",[v._v("ListView 与 RecyclerView区别")]),v._v(" "),i("li",[v._v("RecyclerView性能优化")])]),v._v(" "),i("h3",{attrs:{id:"_9-viewpager-fragment"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_9-viewpager-fragment"}},[v._v("#")]),v._v(" 9.Viewpager&Fragment")]),v._v(" "),i("ul",[i("li",[v._v("Fragment的生命周期 & 结合Activity的生命周期")]),v._v(" "),i("li",[v._v("Activity和Fragment的通信方式， Fragment之间如何进行通信")]),v._v(" "),i("li",[v._v("getFragmentManager、getSupportFragmentManager 、getChildFragmentManager之间的区别？")]),v._v(" "),i("li",[v._v("为什么使用Fragment.setArguments(Bundle)传递参数")]),v._v(" "),i("li",[v._v("FragmentPagerAdapter与FragmentStatePagerAdapter的区别与使用场景")]),v._v(" "),i("li",[v._v("FragmentPageAdapter和FragmentStatePageAdapter区别及使用场景")]),v._v(" "),i("li",[v._v("Fragment懒加载")]),v._v(" "),i("li",[v._v("ViewPager2与ViewPager区别")]),v._v(" "),i("li",[v._v("Fragment嵌套问题")])]),v._v(" "),i("h3",{attrs:{id:"_10-webview"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_10-webview"}},[v._v("#")]),v._v(" 10.WebView")]),v._v(" "),i("ul",[i("li",[v._v("如何提高WebView加载速度")]),v._v(" "),i("li",[v._v("WebView与 js的交互")]),v._v(" "),i("li",[v._v("WebView的漏洞")]),v._v(" "),i("li",[v._v("JsBridge原理")])]),v._v(" "),i("h3",{attrs:{id:"_11-动画"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_11-动画"}},[v._v("#")]),v._v(" 11.动画")]),v._v(" "),i("ul",[i("li",[v._v("动画的类型")]),v._v(" "),i("li",[v._v("补间动画和属性动画的区别")]),v._v(" "),i("li",[v._v("ObjectAnimator，ValueAnimator及其区别")]),v._v(" "),i("li",[v._v("TimeInterpolator插值器，自定义插值器")]),v._v(" "),i("li",[v._v("TypeEvaluator估值器")])]),v._v(" "),i("h3",{attrs:{id:"_12-bitmap"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_12-bitmap"}},[v._v("#")]),v._v(" 12.Bitmap")]),v._v(" "),i("ul",[i("li",[v._v("Bitmap 内存占用的计算")]),v._v(" "),i("li",[v._v("getByteCount() & getAllocationByteCount()的区别")]),v._v(" "),i("li",[v._v("Bitmap的压缩方式")]),v._v(" "),i("li",[v._v("LruCache & DiskLruCache原理")]),v._v(" "),i("li",[v._v("如何设计一个图片加载库")]),v._v(" "),i("li",[v._v("有一张非常大的图片,如何去加载这张大图片")]),v._v(" "),i("li",[v._v("如果把drawable-xxhdpi下的图片移动到drawable-xhdpi下，图片内存是如何变的。")]),v._v(" "),i("li",[v._v("如果在hdpi、xxhdpi下放置了图片，加载的优先级。如果是400_800，1080_1920，加载的优先级。")])]),v._v(" "),i("h3",{attrs:{id:"_13-mvc-mvp-mvvm"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_13-mvc-mvp-mvvm"}},[v._v("#")]),v._v(" 13.mvc&mvp&mvvm")]),v._v(" "),i("ul",[i("li",[v._v("MVC及其优缺点")]),v._v(" "),i("li",[v._v("MVP及其优缺点")]),v._v(" "),i("li",[v._v("MVVM及其优缺点")]),v._v(" "),i("li",[v._v("MVP如何管理Presenter的生命周期，何时取消网络请求")])]),v._v(" "),i("h3",{attrs:{id:"_14-binder"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_14-binder"}},[v._v("#")]),v._v(" 14.Binder")]),v._v(" "),i("ul",[i("li",[v._v("Android中进程和线程的关系,区别")]),v._v(" "),i("li",[v._v("为何需要进行IPC,多进程通信可能会出现什么问题")]),v._v(" "),i("li",[v._v("Android中IPC方式有几种、各种方式优缺点")]),v._v(" "),i("li",[v._v("为何新增Binder来作为主要的IPC方式")]),v._v(" "),i("li",[v._v("什么是Binder")]),v._v(" "),i("li",[v._v("Binder的原理")]),v._v(" "),i("li",[v._v("Binder Driver 如何在内核空间中做到一次拷贝的？")]),v._v(" "),i("li",[v._v("使用Binder进行数据传输的具体过程")]),v._v(" "),i("li",[v._v("Binder框架中ServiceManager的作用")]),v._v(" "),i("li",[v._v("什么是AIDL")]),v._v(" "),i("li",[v._v("AIDL使用的步骤")]),v._v(" "),i("li",[v._v("AIDL支持哪些数据类型")]),v._v(" "),i("li",[v._v("AIDL的关键类，方法和工作流程")]),v._v(" "),i("li",[v._v("如何优化多模块都使用AIDL的情况")]),v._v(" "),i("li",[v._v("使用 Binder 传输数据的最大限制是多少，被占满后会导致什么问题")]),v._v(" "),i("li",[v._v("Binder 驱动加载过程中有哪些重要的步骤")]),v._v(" "),i("li",[v._v("系统服务与bindService启动的服务的区别")]),v._v(" "),i("li",[v._v("Activity的bindService流程")]),v._v(" "),i("li",[v._v("不通过AIDL，手动编码来实现Binder的通信")])]),v._v(" "),i("h3",{attrs:{id:"_15-内存泄漏-内存溢出"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_15-内存泄漏-内存溢出"}},[v._v("#")]),v._v(" 15.内存泄漏&内存溢出")]),v._v(" "),i("ul",[i("li",[v._v("什么是OOM & 什么是内存泄漏以及原因")]),v._v(" "),i("li",[v._v("Thread是如何造成内存泄露的，如何解决？")]),v._v(" "),i("li",[v._v("Handler导致的内存泄露的原因以及如何解决")]),v._v(" "),i("li",[v._v("如何加载Bitmap防止内存溢出")]),v._v(" "),i("li",[v._v("MVP中如何处理Presenter层以防止内存泄漏的")])]),v._v(" "),i("h3",{attrs:{id:"_16-性能优化"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_16-性能优化"}},[v._v("#")]),v._v(" 16.性能优化")]),v._v(" "),i("ul",[i("li",[v._v("内存优化")]),v._v(" "),i("li",[v._v("启动优化")]),v._v(" "),i("li",[v._v("布局加载和绘制优化")]),v._v(" "),i("li",[v._v("卡顿优化")]),v._v(" "),i("li",[v._v("网络优化")])]),v._v(" "),i("h3",{attrs:{id:"_17-window-windowmanager"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_17-window-windowmanager"}},[v._v("#")]),v._v(" 17.Window&WindowManager")]),v._v(" "),i("ul",[i("li",[v._v("什么是Window")]),v._v(" "),i("li",[v._v("什么是WindowManager")]),v._v(" "),i("li",[v._v("什么是ViewRootImpl")]),v._v(" "),i("li",[v._v("什么是DecorView")]),v._v(" "),i("li",[v._v("Activity，View，Window三者之间的关系")]),v._v(" "),i("li",[v._v("DecorView什么时候被WindowManager添加到Window中")])]),v._v(" "),i("h3",{attrs:{id:"_18-wms"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_18-wms"}},[v._v("#")]),v._v(" 18.WMS")]),v._v(" "),i("ul",[i("li",[v._v("什么是WMS")]),v._v(" "),i("li",[v._v("WMS是如何管理Window的")]),v._v(" "),i("li",[v._v("IWindowSession是什么，WindowSession的创建过程是怎样的")]),v._v(" "),i("li",[v._v("WindowToken是什么")]),v._v(" "),i("li",[v._v("WindowState是什么")]),v._v(" "),i("li",[v._v("Android窗口大概分为几种？分组原理是什么")]),v._v(" "),i("li",[v._v("Dialog的Context只能是Activity的Context，不能是Application的Context")]),v._v(" "),i("li",[v._v("App应用程序如何与SurfaceFlinger通信的")]),v._v(" "),i("li",[v._v("View 的绘制是如何把数据传递给 SurfaceFlinger 的")]),v._v(" "),i("li",[v._v("共享内存的具体实现是什么")]),v._v(" "),i("li",[v._v("relayout是如何向SurfaceFlinger申请Surface")]),v._v(" "),i("li",[v._v("什么是Surface")])]),v._v(" "),i("h3",{attrs:{id:"_19-ams"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_19-ams"}},[v._v("#")]),v._v(" 19.AMS")]),v._v(" "),i("ul",[i("li",[v._v("ActivityManagerService是什么？什么时候初始化的？有什么作用？")]),v._v(" "),i("li",[v._v("ActivityThread是什么?ApplicationThread是什么?他们的区别")]),v._v(" "),i("li",[v._v("Instrumentation是什么？和ActivityThread是什么关系？")]),v._v(" "),i("li",[v._v("ActivityManagerService和zygote进程通信是如何实现的")]),v._v(" "),i("li",[v._v("ActivityRecord、TaskRecord、ActivityStack，ActivityStackSupervisor，ProcessRecord")]),v._v(" "),i("li",[v._v("ActivityManager、ActivityManagerService、ActivityManagerNative、ActivityManagerProxy的关系")]),v._v(" "),i("li",[v._v("手写实现简化版AMS")])]),v._v(" "),i("h3",{attrs:{id:"_20-系统启动"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_20-系统启动"}},[v._v("#")]),v._v(" 20.系统启动")]),v._v(" "),i("ul",[i("li",[v._v("android系统启动流程")]),v._v(" "),i("li",[v._v("SystemServer，ServiceManager，SystemServiceManager的关系")]),v._v(" "),i("li",[v._v("孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote")]),v._v(" "),i("li",[v._v("Zygote的IPC通信机制为什么使用socket而不采用binder")])]),v._v(" "),i("h3",{attrs:{id:"_21-app启动-打包-安装"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_21-app启动-打包-安装"}},[v._v("#")]),v._v(" 21.App启动&打包&安装")]),v._v(" "),i("ul",[i("li",[v._v("应用启动流程")]),v._v(" "),i("li",[v._v("apk组成和Android的打包流程")]),v._v(" "),i("li",[v._v("Android的签名机制，签名如何实现的,v2相比于v1签名机制的改变")]),v._v(" "),i("li",[v._v("APK的安装流程")])]),v._v(" "),i("h3",{attrs:{id:"_22-序列化"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_22-序列化"}},[v._v("#")]),v._v(" 22.序列化")]),v._v(" "),i("ul",[i("li",[v._v("什么是序列化")]),v._v(" "),i("li",[v._v("为什么需要使用序列化和反序列化")]),v._v(" "),i("li",[v._v("序列化的有哪些好处")]),v._v(" "),i("li",[v._v("Serializable 和 Parcelable 的区别")]),v._v(" "),i("li",[v._v("什么是serialVersionUID")]),v._v(" "),i("li",[v._v("为什么还要显示指定serialVersionUID的值?")])]),v._v(" "),i("h3",{attrs:{id:"_23-模块化-组件化"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_23-模块化-组件化"}},[v._v("#")]),v._v(" 23.模块化&组件化")]),v._v(" "),i("ul",[i("li",[v._v("什么是模块化")]),v._v(" "),i("li",[v._v("什么是组件化")]),v._v(" "),i("li",[v._v("组件化优点和方案")]),v._v(" "),i("li",[v._v("组件独立调试")]),v._v(" "),i("li",[v._v("组件间通信")]),v._v(" "),i("li",[v._v("Aplication动态加载")]),v._v(" "),i("li",[v._v("ARouter原理")])]),v._v(" "),i("h3",{attrs:{id:"_24-热修复-插件化"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_24-热修复-插件化"}},[v._v("#")]),v._v(" 24.热修复&插件化")]),v._v(" "),i("ul",[i("li",[v._v("插件化的定义")]),v._v(" "),i("li",[v._v("插件化的优势")]),v._v(" "),i("li",[v._v("插件化框架对比")]),v._v(" "),i("li",[v._v("插件化流程")]),v._v(" "),i("li",[v._v("插件化类加载原理")]),v._v(" "),i("li",[v._v("插件化资源加载原理")]),v._v(" "),i("li",[v._v("插件化Activity加载原理")]),v._v(" "),i("li",[v._v("热修复和插件化区别")]),v._v(" "),i("li",[v._v("热修复原理")])]),v._v(" "),i("h3",{attrs:{id:"_25-aop"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_25-aop"}},[v._v("#")]),v._v(" 25.AOP")]),v._v(" "),i("ul",[i("li",[v._v("AOP是什么")]),v._v(" "),i("li",[v._v("AOP的优点")]),v._v(" "),i("li",[v._v("AOP的实现方式,APT,AspectJ,ASM,epic,hook")])]),v._v(" "),i("h3",{attrs:{id:"_26-jectpack"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_26-jectpack"}},[v._v("#")]),v._v(" 26.Jectpack")]),v._v(" "),i("ul",[i("li",[v._v("Navigation")]),v._v(" "),i("li",[v._v("DataBinding")]),v._v(" "),i("li",[v._v("Viewmodel")]),v._v(" "),i("li",[v._v("livedata")]),v._v(" "),i("li",[v._v("liferecycle")])]),v._v(" "),i("h3",{attrs:{id:"_27-开源框架"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_27-开源框架"}},[v._v("#")]),v._v(" 27.开源框架")]),v._v(" "),i("ul",[i("li",[v._v("Okhttp源码流程,线程池")]),v._v(" "),i("li",[v._v("Okhttp拦截器,addInterceptor 和 addNetworkdInterceptor区别")]),v._v(" "),i("li",[v._v("Okhttp责任链模式")]),v._v(" "),i("li",[v._v("Okhttp缓存怎么处理")]),v._v(" "),i("li",[v._v("Okhttp连接池和socket复用")]),v._v(" "),i("li",[v._v("Glide怎么绑定生命周期")]),v._v(" "),i("li",[v._v("Glide缓存机制,内存缓存，磁盘缓存")]),v._v(" "),i("li",[v._v("Glide与Picasso的区别")]),v._v(" "),i("li",[v._v("LruCache原理")]),v._v(" "),i("li",[v._v("Retrofit源码流程,动态代理")]),v._v(" "),i("li",[v._v("LeakCanary弱引用,源码流程")]),v._v(" "),i("li",[v._v("Eventbus")]),v._v(" "),i("li",[v._v("Rxjava")])]),v._v(" "),i("h2",{attrs:{id:"二-java面试相关"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#二-java面试相关"}},[v._v("#")]),v._v(" 二. Java面试相关")]),v._v(" "),i("h3",{attrs:{id:"_1-hashmap"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-hashmap"}},[v._v("#")]),v._v(" 1.HashMap")]),v._v(" "),i("ul",[i("li",[v._v("HashMap原理")]),v._v(" "),i("li",[v._v("HashMap 有用过吗？您能给我说说他的主要用途吗？")]),v._v(" "),i("li",[v._v("您能说说 HashMap 常用操作的底层实现原理吗？如存储 put(K key, V value)，查找 get(Object key)，删除 remove(Object                                key)，修改 replace(K key, V value)等操作")]),v._v(" "),i("li",[v._v("hash 冲突（或者叫 hash 碰撞）是什么？为什么会出现这种现象，如何解 决 hash 冲突？")]),v._v(" "),i("li",[v._v("HashMap 的容量为什么一定要是 2 的 n 次方？")]),v._v(" "),i("li",[v._v("您能说说 HashMap 和 HashTable 的区别吗？")]),v._v(" "),i("li",[v._v("HashMap中put()如何实现的")]),v._v(" "),i("li",[v._v("HashMap中get()如何实现的")]),v._v(" "),i("li",[v._v("为什么HashMap线程不安全")]),v._v(" "),i("li",[v._v("HashMap1.7和1.8有哪些区别")]),v._v(" "),i("li",[v._v("解决hash冲突的时候，为什么用红黑树")]),v._v(" "),i("li",[v._v("红黑树的效率高，为什么一开始不用红黑树存储")]),v._v(" "),i("li",[v._v("不用红黑树，用二叉查找树可以不")]),v._v(" "),i("li",[v._v("为什么阀值是8才转为红黑树")]),v._v(" "),i("li",[v._v("为什么退化为链表的阈值是6")]),v._v(" "),i("li",[v._v("hash冲突有哪些解决办法")]),v._v(" "),i("li",[v._v("HashMap在什么条件下扩容")]),v._v(" "),i("li",[v._v("HashMap中hash函数怎么实现的，还有哪些hash函数的实现方式")]),v._v(" "),i("li",[v._v("为什么不直接将hashcode作为哈希值去做取模,而是要先高16位异或低16位")]),v._v(" "),i("li",[v._v("为什么扩容是2的次幂")]),v._v(" "),i("li",[v._v("链表的查找的时间复杂度是多少")]),v._v(" "),i("li",[v._v("红黑树")])]),v._v(" "),i("h3",{attrs:{id:"_2-arraylist"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-arraylist"}},[v._v("#")]),v._v(" 2.ArrayList")]),v._v(" "),i("ul",[i("li",[v._v("ArrayList定义")]),v._v(" "),i("li",[v._v("ArrayList 的构造器")]),v._v(" "),i("li",[v._v("add 方法源码分析")]),v._v(" "),i("li",[v._v("get 方法源码分析")]),v._v(" "),i("li",[v._v("set 方法源码分析")]),v._v(" "),i("li",[v._v("ArrayList和LinkedList的区别，以及应用场景")])]),v._v(" "),i("h3",{attrs:{id:"_3-linkedlist"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-linkedlist"}},[v._v("#")]),v._v(" 3. LinkedList")]),v._v(" "),i("ul",[i("li",[v._v("LinkedList 定义")]),v._v(" "),i("li",[v._v("LinkedList 支持的操作")]),v._v(" "),i("li",[v._v("Node 类")]),v._v(" "),i("li",[v._v("addFirst 源码分析")]),v._v(" "),i("li",[v._v("getFirst 方法源码分析")]),v._v(" "),i("li",[v._v("removeFirst 方法源码分析")]),v._v(" "),i("li",[v._v("add(int index, E e)方法源码分析")])]),v._v(" "),i("h3",{attrs:{id:"_4-hashset-源码"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4-hashset-源码"}},[v._v("#")]),v._v(" 4. Hashset 源码")]),v._v(" "),i("ul",[i("li",[v._v("属性")]),v._v(" "),i("li",[v._v("构造方法")]),v._v(" "),i("li",[v._v("添加元素")]),v._v(" "),i("li",[v._v("删除元素")]),v._v(" "),i("li",[v._v("查询元素")]),v._v(" "),i("li",[v._v("遍历元素")]),v._v(" "),i("li",[v._v("全部源码")])]),v._v(" "),i("h3",{attrs:{id:"_5-内存模型"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_5-内存模型"}},[v._v("#")]),v._v(" 5. 内存模型")]),v._v(" "),i("ul",[i("li",[v._v("内存模型产生背景")]),v._v(" "),i("li",[v._v("物理机的并发问题")]),v._v(" "),i("li",[v._v("Java 内存模型的组成分析")]),v._v(" "),i("li",[v._v("Java 内存间的交互操作")]),v._v(" "),i("li",[v._v("Java 内存模型运行规则")])]),v._v(" "),i("h3",{attrs:{id:"_6-垃圾回收算法-jvm"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_6-垃圾回收算法-jvm"}},[v._v("#")]),v._v(" 6. 垃圾回收算法（JVM）")]),v._v(" "),i("ul",[i("li",[v._v("Jvm的内存模型,每个里面都保存的什么")]),v._v(" "),i("li",[v._v("类加载机制的几个阶段加载、验证、准备、解析、初始化、使用、卸载")]),v._v(" "),i("li",[v._v("对象实例化时的顺序")]),v._v(" "),i("li",[v._v("类加载器,双亲委派及其优势")]),v._v(" "),i("li",[v._v("垃圾回收机制")]),v._v(" "),i("li",[v._v("谈谈对 JVM 的理解?")]),v._v(" "),i("li",[v._v("JVM 内存区域，开线程影响哪块区域内存？")]),v._v(" "),i("li",[v._v("对 Dalvik、ART 虚拟机有什么了解？对比")])]),v._v(" "),i("h3",{attrs:{id:"_7-多线程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_7-多线程"}},[v._v("#")]),v._v(" 7.多线程")]),v._v(" "),i("ul",[i("li",[v._v("谈一谈java线程模型")]),v._v(" "),i("li",[v._v("Java中创建线程的方式,Callable,Runnable,Future,FutureTask")]),v._v(" "),i("li",[v._v("线程的几种状态")]),v._v(" "),i("li",[v._v("谈谈线程死锁，如何有效的避免线程死锁？")]),v._v(" "),i("li",[v._v("如何实现多线程中的同步")]),v._v(" "),i("li",[v._v("synchronized和Lock的使用、区别,原理；")]),v._v(" "),i("li",[v._v("volatile，synchronized和volatile的区别？为何不用volatile替代synchronized？")]),v._v(" "),i("li",[v._v("锁的分类，锁的几种状态，CAS原理")]),v._v(" "),i("li",[v._v("为什么会有线程安全？如何保证线程安全")]),v._v(" "),i("li",[v._v("sleep()与wait()区别,run和start的区别,notify和notifyall区别,锁池,等待池")]),v._v(" "),i("li",[v._v("Java多线程通信")]),v._v(" "),i("li",[v._v("为什么Java用线程池")]),v._v(" "),i("li",[v._v("Java中的线程池参数,共有几种")]),v._v(" "),i("li",[v._v("说下 Java 中的线程创建方式，线程池的工作原理")])]),v._v(" "),i("h3",{attrs:{id:"_8-注解"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_8-注解"}},[v._v("#")]),v._v(" 8.注解")]),v._v(" "),i("ul",[i("li",[v._v("注解的分类和底层实现原理")]),v._v(" "),i("li",[v._v("自定义注解")])]),v._v(" "),i("h3",{attrs:{id:"_9-反射"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_9-反射"}},[v._v("#")]),v._v(" 9.反射")]),v._v(" "),i("ul",[i("li",[v._v("什么是反射")]),v._v(" "),i("li",[v._v("反射机制的相关类")]),v._v(" "),i("li",[v._v("反射中如何获取Class类的实例")]),v._v(" "),i("li",[v._v("如何获取一个类的属性对象 & 构造器对象 & 方法对象")]),v._v(" "),i("li",[v._v("Class.getField和getDeclaredField的区别，getDeclaredMethod和getMethod的区别")]),v._v(" "),i("li",[v._v("反射机制的优缺点")])]),v._v(" "),i("h3",{attrs:{id:"_10-泛型"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_10-泛型"}},[v._v("#")]),v._v(" 10.泛型")]),v._v(" "),i("ul",[i("li",[v._v("泛型概念的提出（为什么需要泛型）？")]),v._v(" "),i("li",[v._v("什么是泛型？")]),v._v(" "),i("li",[v._v("自定义泛型接口、泛型类和泛型方法")]),v._v(" "),i("li",[v._v("类型通配符")])]),v._v(" "),i("h3",{attrs:{id:"_11-设计模式"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_11-设计模式"}},[v._v("#")]),v._v(" 11.设计模式")]),v._v(" "),i("ul",[i("li",[v._v("你所知道的设计模式有哪些")]),v._v(" "),i("li",[v._v("单例设计模式")]),v._v(" "),i("li",[v._v("工厂设计模式")]),v._v(" "),i("li",[v._v("建造者模式（Builder）")]),v._v(" "),i("li",[v._v("适配器设计模式")]),v._v(" "),i("li",[v._v("装饰模式（Decorator）")]),v._v(" "),i("li",[v._v("策略模式（strategy）")]),v._v(" "),i("li",[v._v("观察者模式（Observer）")])])])}),[],!1,null,null,null);_.default=a.exports}}]);