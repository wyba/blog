---
title: Java基础
date: 2022-04-25 09:50:02
permalink: /pages/131fdc/
categories:
  - Java
tags:
  - Java基础
---

> 基础乃重中之重

## 1、面向对象和面向过程的区别

1、思路不同

2、特点不同

3、优势不同

面向过程是直接将解决问题的步骤分析出来，然后用函数把步骤一步一步实现，然后再依次调用就可以了；

面向对象是将构成问题的事物，分解成若干个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在解决问题过程中的行为

面向过程是一种以过程为中心的编程思想，面向过程编程是基于“冯·诺依曼”模型的。面向过程的优点：流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。缺点：需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。

面向对象优点：易维护、易扩展、易复用，有封装、继承、多态的特性、更容易设计出耦合的系统。缺点：性能比面向过程低。

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/377adab44aed2e73136da35fe5bea78186d6fa02.jpeg)



## 2、Java语言的特点是什么？

**1．简单易用**

Java是一种相对简单的编程语言，它通过提供最基本的方法来完成指定的任务，只需掌握一些基础的概念和语法，就可以编写出很多实际可用的应用程序。Java丢弃了C++中很难理解的运算符重载、多重继承等模糊概念。特别是Java语言不使用指针，而是使用引用，并提供了自动的垃圾回收机制，使程序员不必过多的操心内存管理的问题。

**2．安全可靠**

Java通常被用在网络环境中，为此，Java提供了一套可靠的安全机制来防止恶意代码的攻击。Java程序运行之前会利用字节确认器进行代码的安全检查，确保程序不会存在非法访问本地资源、文件系统的可能，保证了程序在网络间传送的安全性。

**3．跨平台**

Java引入了虚拟机的概念，通过Java虚拟机（Java Virtual Machine，称为JVM）可以在不同的操作系统上（如Windows、Linux等）运行Java程序，从而实现跨平台特性。

**4．面向对象**

Java将一切事物都看成对象，通过面向对象的方式，将现实世界的事物抽象成对象，将现实世界中的关系（如父子关系）抽象为继承。这种面向对象的方法，更利于用人们对复杂程序的理解、分析、设计和编写。

**5．支持多线程**

Java语言内置了多线程控制，可使用户程序并发执行。利用Java的多线程编程接口，开发人员可以方便地写出多线程的应用程序，提高程序的执行效率。

## 3、JDK，JRE，JVM三者之间的关系

1. JDK

JDK（Java Development Kit），java开发工具包，它是一种用于构建在 Java 平台上发布的应用程序、applet 和组件的开发环境。其中包括了Java编译器、JVM、大量的Java工具以及Java基础API。

我们在安装了JDK之后，在bin目录下，存放了许多开发工具。常用的有javac.exe（编译工具），将java文件编译成字节码文件（后缀为.class）；java.exe（运行工具），运行编译后的字节码文件。

2. JRE

JRE（Java Runtime Environment），java运行环境 。包含JVM标准实现及Java核心类库。它不包含任何开发工具-编译器、调试器和其它工具。

3. JVM

JVM（Java Virtual Machine），JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指 令，管理数据、内存、寄存器。Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”

JDK是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。

JRE是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。

JVM是整个java实现跨平台的最核心的部分，能够运行以Java语言写的程序。

JDK，JRE，JVM三者之间的关系可以用下图表示：

![JDK，JRE，JVM三者之间的关系](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200206210846897.png)

## 4、JDK和OpenJDK的区别

**1.授权协议的不同**

OpenJDK采用GPL V2协议发布，而JDK则采用JRL协议发布。两个协议虽然都是开放源代码的，但是在使用上的不同在于GPL V2允许在商业上使用，而JRL只允许个人研究使用。

**2.OpenJDK只包含最精简的JDK**

OpenJDK不包含其他的软件包，比如Rhino Java DB JAXP……，并且可以分离的软件包也都是尽量的分离，但是这大多数都是自由软件，你可以自己下载加入。

**3.OpenJDK源代码不完整**

这个很容易想到，在采用GPL协议的OpenJDK中，SUN JDK的一部分源代码因为产权的问题无法开放OpenJDK使用，其中最主要的部分就是JMX中的可选元件SNMP部分的代码。

因此这些不能开放的源代码将它作成plug，以供OpenJDK编译时使用，你也可以选择不要使用plug。

而Icedtea则为这些不完整的部分开发了相同功能的源代码(OpenJDK6)，促使OpenJDK更加完整。

**4.OpenJDK和IcedTea的关系**

IcedTea项目最初是由于OpenJDK不完整（因产权 而造成的障碍）而创立的，社区需要一个完整的开源工具链及代码库。

IcedTea长期以来一直是OpenJDK的一套补丁，正如刚才我所说到的，它有一个 基于“./configure”的不同的构建系统。

在OpenJDK中，我们已经替换了产权代码（encumbered code），因此不再有障碍了。正因为我们的努力，IcedTea项目已经减少了使用补丁的数量。

IcedTea中看上去不错的一点是，它的 configure脚本使得在多种不同的模式下构建OpenJDK变得很容易，比如使用Zero Assembler Port在非x86/sparc芯片上来支持编译等等。

IcedTea提供的一大块内容是plugin/java-web-start基础架构。

**5.部分源代码用开源代码替换**

由于产权的问题，很多是SUN JDK的源代码被替换成一些功能相同的开源代码，比如说字体栅格化引擎，使用Free Type代替。

**6.不能使用Java商标**

这个很容易理解，在安装OpenJDK的机器上，输入“java -version”显示的是OpenJDK，但是如果是使用Icedtea补丁的OpenJDK，显示的是java。（未验证）

## 5、字符型常量和字符串常量的区别？

1. 形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；

   

2. 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象；

   

3. 占内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意: char 在Java中占两个字节)。

## 6、Java中重写和重载有哪些区别

Java中方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同，参数个数不同或者两者都不同），则视为重载；

重写发生在子类和父类之间，重写要求子类重写方法和父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（LSP里氏替换原则）。重载对返回类型没有特殊要求。

方法重载的规则：

1. 方法名一致（完全相同），参数列表中参数的顺序，类型，个数不同。
2. 重载与方法的返回值无关，存在于一个类中。
3. 可以抛出不同的异常，可以有不同的修饰符。

方法重写的规则：

a. 参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。也就是方法的躯壳是一样的，不同的是方法体里面的内容。

b. 构造方法不能被重写，声明为final的方法不能被重写，声明为static的方法不能被重写，但是能够被再次声明。

c. 访问权限不能比父类中被重写的方法的访问权限更低。

d. 重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

## 7、JAVA面向对象的三大特征

###### java面向对象的三大特征：封装、继承、多态

### 1 封装

将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。

好处

 a.只能通过规定的方法访问数据；

 b.隐藏类的实现细节，方便修改和实现；

 c.高内聚，低耦合。高内聚：类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。

访问修饰符的总结：

![image-20220425112811236](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/image-20220425112811236.png)

java中的this关键字

- 1.this关键字代表当前对象
   this.属性 操作当前对象的属性
   this.方法 操作当前对象的方法
- 2.封装对象的属性的时候，经常会使用this关键字。
- 3.普通方法中：this总是指向调用该方法的对象；
   构造方法中：this总是指向正要初始化的对象。

内部类

一般情况下，把类定义成独立的单元；有些情况下，把一个类定义在另一个类的内部，即内部类。

内部类的作用：

提供了更好的封装。只能让外部类直接访问，不允许同一个包的其他类直接访问；内部类可以直接访问外部类的私有属性，内部类被当成外部类的成员。但外部类不能访问内部类的内部属性。

java中的静态内部类

静态内部类是用static修饰的内部类，特点：

1、静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 ；

2、 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员；

3、 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类()。

方法内部类

1. 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。

   

2. 注意：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。

### 2 继承

把多种有着共同特性的多的类事物抽象成一个类，这个类就是多个类的父类。父类的意义在于可以抽取多个类的共性，代码复用，减少代码量。

类是对对象的抽象，继承是对某一批类的抽象，从而实现对现实世界更好的建模。

提高代码的复用性。

子类继承父类，可以得到父类的全部属性和方法（除了父类中的构造方法）。

java中只有单继承，没有像c++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。

java中的多继承可以通过接口来实现。


方法重写：

- 如果子类对继承父类的方法不满意，是可以重写父类继承的方法的，当调用方法时会优先调用子类的方法。
- 重写方法必须和被重写方法具有相同方法名称、参数列表和返回类型。
- 重写方法不能使用比被重写方法更严格的访问权限（由于多态）。

继承的初始化顺序

先初始化父类再初始化子类；

 先执行初始化对象中的属性，再执行构造方法中的初始化。

java中的final关键字的使用

final关键字做标识有“最终的”含义。

final可以修饰类、方法、属性和变量。

1.修饰类：则该类不允许被继承；

2.修饰方法：则该方法不允许被覆盖（重写）；

3.修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值；

4.修饰变量：则该变量的值只能赋一次值，即为常量。

Java中的super关键字的使用

super关键字：在对象的内部使用，可以代表父类对象。

1.访问父类的属性：
super.age

2.访问父类的方法：
super.eat（）

super的应用

1.子类的构造过程当中必须调用其父类的构造方法。

2.如果子类的构造方法当中没有显示调用父类的构造方法，则系统会默认调用父类无参的构造方法（通过super关键字）。

3.如果显示的调用构造方法，必须写在子类的构造方法的第一行（super（）；）。

4.如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则编译出错。

java中的Object类

Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类。Object类中的方法，适合所有子类。

几个重要的方法

1.toString（）方法：

在Object类中定义toString（）方法的时候，返回的是对象的哈希code码（对象地址字符串）。可以通过重写toString（）方法表示出对象的属性。

2.equals（）方法：

比较的是对象的引用是否指向同一块内存地址。

### 3 多态

多态性：允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 

多态：对象的多种形态。多态是oop中的一个重要特性，主要是用来实现动态联编的，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。

引用变量的两种类型：

1.编译时类型：模糊一点，一般是一个父类；由声明时的类型决定。

2.运行时类型：运行时，具体是那个子类就是哪个子类；由实际对应的对象类型决定。

多态类型：

1.引用多态：

a.父类的引用可以指向本类的对象。

b.父类的引用可以指向子类的对象。

2.方法多态：

a.创建本类对象时，调用的方法为本类方法。

b.创建子类对象时，调用的方法为子类重写的方法或者继承的方法

## 8、如何判断两个对象是否相等

equals方法是 **`判断两个对象是否相等`**。

在Object类中的equals方法当中，默认采用的是“`==` ”判断两个java对象是否相等。

 而“ `==`”判断的是两个java对象的 **`内存地址`**，

 我们应该判断两个java对象的内容是否相等。所以老祖宗的equals方法不够用，需要子类重写equals。

**基本数据类型，判断相等用“==”**；

**引用数据类型，判断相等必须重写equals()方法，不然比较的是内存地址。**

**以后自己写的类equals()方法必须重写！！**

**equals方法重写的时候要彻底！！！即每个类都要重写**

**String重写了toString()方法和equals()方法**

**判断两个字符串是否相等不要用"=="，用字符串对象的equals()方法！**

## 9、String，StringBuffer，StringBuilder三者有什么异同？

**相同点：**

#### 1、三者都是Java平台提供的三种类型得到字符串，它们可以储存和操作字符串。

**不同点：**

#### 1、String是final修饰的，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder表示的字符串对象可以直接进行修改。

#### 2、StringBuilder是Java5引入的，它和StringBuffer的方法完全相同，区别在于，StringBuilder是在单线程环境下使用的，它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。

#### 3、StringBuffer是线程安全的，而StringBuilder是线程非安全的。

#### 4、执行速度方面：**StringBuilder > StringBuffer > String** 

**对三者使用的总结：**

1、当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。

当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。

2、如果要操作少量的数据用 = String

　单线程操作字符串缓冲区 下操作大量数据 = StringBuilder

　多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

String类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20201211111843767.png)

可以看出来，再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收。

## 10、静态方法为什么不能调用非静态成员(成员方法和成员变量)？

静态方法在项目编译时就运行了，是属于类的。

 当new对象时会调用构造器，实例化对象，非静态变量才存在

 静态方法在编译的时候非静态变量还不存在，而动态方法只能通过对象来调用，所以静态方法不能调用非静态成员。

非静态方法可以调用静态成员。

总结：静态的存在时间和非静态存在的时间不一样

## 11、Java的自动装箱与拆箱

简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。

为什么会有装箱和拆箱的出现？

是java早年设计缺陷。基础类型是数据，不是对象，也不是Object的子类。

 需要装箱才能和其他Object的子类共用同一个接口。

注意： 
 1、什么时候会引发装箱和拆箱 
 2、装箱操作会创建对象，频繁的装箱操作会消耗许多内存，影响性能，所以可以避免装箱的时候应该尽量避免。

自动拆装箱带来的问题

1.包装对象之间的数值比较不能简单的使用==，除了特殊情况(如Integer的-128~127),其他比较都需要使用equals比较

2.如果包装类对象为NULL，那么自动拆箱就可能会抛出NPE

3.如果一个for循环中有大量拆装箱操作，会浪费很多资源

## 12、抽象类与接口的区别

不同点：

1.子类只能继承一个抽象类，但可以实现多个接口

2.一个类实现一个接口必须实现接口中的所有方法，但抽象类不用

3.抽象类中的成员变量可以是任意类型的，而接口中的成员变量只能是public static final

4.接口中只能定义抽象方法，而抽象类中可以定义非抽象方法

5.抽象类中可以有静态方法和静态代码块，而接口中不可以

6.接口不可以被实例化，没有构造方法，但抽象类可以有构造方法

相同点：

（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

## 13、在Java中定义无参构造方法的作用?

Java程序在执行子类的构造方法之前，如果没有使用super()调用父类特定的构造方法，则会默认调用父类中的无参构造方法。

如果父类中没有无参构造方法，而子类又没有使用super()调用父类中特定的构造方法，则编译时会出错。

## 14、Java中==和equals的区别

在JAVA中，==与equals都有比较判断对象是否相等的作用，但具体用法却并不相同。

**属性不同:**

   ==是运算符号，而equals则属于方法。

**用法不同:**

   当==两边的对象属于**基本类型**时，==的作用仅是比较对象的值是否相等，如果相等返回true，否则返回false;

   当两边的对象属于**引用数据类型**时，==的作用是判断对象的内存地址是否一致，如果同时指向同一地址，则返回true，否则返回false.

  equals两边对象**只能属于引用数据类型**，因为equals是方法，所以它是如何具体判断对象是否相等是根据程序而定的，equals是属于  object类，默认是判断内存地址是否相同，但在object的子类中可以重写equals方法，如在String类中只是比较对象内容是否一致，一致 则返回true，否则返回false

```java
String s1= "abc";
String s2 = "abc";
System.out.println(s1==s2);
System.out.println(s1.equals(s2));
```

结果: true. true. 因为在常量池中，一个常量只会对应一个地址，因此不管是再多的 "abc", 这样的数据都只会存储一个地址. 所以所有他们的引用都是指向的同一块地址，因此基本数据类型和String常量是可以直接通过==来直接比较的。

## 15、Java中hashcode和equals详解

hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置，也即hashcode其实就是个位置，在hash表中的位置（可以想象成数组的下标位置）。

 HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的

**equals和hashcode的关系**

先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。

1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同

2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置

比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。

hashCode()的作用就是获取哈希码，也称散列码；它实际上是返回一个int整数，这个***哈希码的作用***是确定该对象在哈希表中的索引位置。hashCode（）在散列表中才有用，在其他情况下没用。

1. 如果两个对象相等，则hashCode一定相等（值）；
2. 两个对象相等，对两个对象分别调用equals方法都返回true（如果这两个对象是两个对象的话，这种情况下一定是重写了hashCode与equals方法，否则一定不等）
3. 两个对象有相同发hashCode值，它们也不一定是相等的（没有重写equals方法）
4. 因此，equals方法被覆盖过，则hashCode也必须被覆盖
5. hashCode的默认行为是对堆上的对象产生独特值；如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

## 16、局部变量和成员变量区别

1、位置不一样

局部变量：在方法的内部

成员变量：在方法的外部、直接写在类当中

2、作用范围不一样（作用域）

局部变量：只有方法当中可用，出了方法就不可用

成员变量：整个类都可用

3、默认值不一样

局部变量：没有默认值，使用前必须手动赋值

成员变量：如果没有赋值，会有默认值，赋值规则和数组一样

4、内存的位置不一样

局部变量：位于栈内存

成员变量：位于堆内存

5、生命周期不一样

局部变量：随着方法栈而诞生，随着方法出栈而结束

成员变量：随着对象创建而诞生，随着对象被垃圾回收而结束

## 17、为什么Java中只有值传递？

实参：方法被调用时传入的实际值。

形参：在定义方法时括号内定义的参数列表即为形参，它用来接收方法调用时传入的实参。

值传递：当方法被调用时，实参通过形参将其副本传入方法内，接下来对形参的操作就是在对实参副本的操作，并不会影响实参本身。

引用传递：当方法被调用时，实参的地址值通过形参将其传入方法内，所以对形参的改变就会映射到实参上。

 **注意：值传递与引用传递的区别并不在于被传递参数的类型，也就是说，并不是传入的参数是基本数据类型就是值传递，同理，并不是传入的参数是引用类型就是引用传递。**

（1）当形参为基本数据类型时：这个过程虽然改变了形参，但是并没有改变实参的值，所以说是一次值传递过程

（2）当形参为引用类型时：传递的参数并不是Person对象的具体值，而是它的地址值，所以实参、形参指向的是堆内存中的同一个Person对象，这样我们对形参的修改就会体现在实参上。

（3）当形参为String等不可变类（Integer等包装类）时：因为String是不可变类，它一旦初始化就不可以再更改值了

**所以，值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。**

**所以说，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。**

## 18、关于final的一些总结

1. `final`修饰类:表示该类不可继承；
    `final`不能修饰`interface`接口
2. `final`修饰方法:表示该方法不能被子类覆盖(即子类不能重写父类的`final`方法,可以继承)；
    `final`不能修饰构造函数
3. `final`修饰字段属性:表示属性值第一次初始化后不能被修改
    `final`属性可以直接初始化或在构造函数中初始化，如果属性是直接初始化，则其值不能被其它函数(包括构造函数)修改
4. `final`修饰函数参数，参数值不能被函数修改
5. `final`修饰函数中的局部变量，局部变量被第一次初始化后不能被修改

使用`final`的意义：

1. 为方法`上锁`，防止任何继承类改变它的本来含义和实现。设计程序时，若希望一个方法的行为在继承期间保持不变，而且不可被覆盖或改写，就可以采取这种做法。
2. 提高程序执行的效率，将一个方法设成`final`后，编译器就可以把对那个方法的所有调用都置入`嵌入`调用里（内嵌机制）。

## 19、关于static的一些总结

1. `static`修饰成员函数:该成员函数不能使用`this`对象
    `static`不能修饰构造函数
    `static`不能修饰函数参数
    `static`不能修饰局部成员变量
2. `static`修饰成员字段
    当类被虚拟机加载时，首先按照字段声明的先后顺序对`static`成员字段进行初始化
3. `static`修饰语句块
    当类被虚拟机加载时，按照声明顺序先后初始化`static`成员字段和`static`语句块
    `static`所修饰的方法和字段是只属于类，所有对象共享。
    在`static`所修饰的函数和语句块中不能使用`非static`成员字段。
    在`Java`不能直接定义全局变量，是通过`static`来实现的
    在`Java`中没有`const`，不能直接定义常量，通过`static final`来实现
4. 静态变量在编译期还是运行期加载，以及静态代码块加载的时机
    当类加载器将类加载到`JVM`中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含`this`或者`super`,它们通常被用初始化静态变量

## 20、Java异常处理机制

 程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常（开发过程中的语法错误和逻辑错误不是异常）。

   Java程序在执行过程中所发生的异常事件可分为两类：

​        Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError（栈溢出）和OOM（内存溢出）。一般不编写针对性的代码进行处理。

​        Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：
​            空指针访问
​            试图读取不存在的文件
​            网络连接中断
​            数组角标越界

**Error和Exception的区别:**

 Error和Exception都有一个共同的根类是Throwable类。 

Error是系统中的错误，程序员是不能改变的和处理的，一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。因此我们编写程序时不需要关心这类错误。

 Exception，也就是我们经常见到的一些异常情况，表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/721cce36b3f741a388d0a3b61fc6da07.png)



Exception异常划分Exception异常进行划分，它可分为**运行时异常**和**编译期异常**。

 运行时异常：
                是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。

 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。

 编译期异常：
                是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不要自定义检查异常。

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/d736e91e7a344d7b977bac580e149318.png)

### try-catch-finally

```java
   try{
            ...... //可能产生异常的代码
        }
        catch( ExceptionName1 e ){
            ...... //当产生ExceptionName1型异常时的处置措施
        }
        catch( ExceptionName2 e ){
            ...... //当产生ExceptionName2型异常时的处置措施
        }
        [ finally{
            ...... //无论是否发生异常，都无条件执行的语句
        } ]
```

需要注意的地方

 1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。

  2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。

  3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。

有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式）

 而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）

```java
public static void main(String[] args){
    try {
        foo();
    }catch(ArithmeticException ae) {
        System.out.println("处理异常");
    }
}
public static void foo(){
    int a = 5/0;  //异常抛出点
    System.out.println("Look me!!!");  //不会执行
}
```

  finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。

### throws

throws是另一种处理异常的方式，它不同于try...catch...finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。

throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉或并不能确定如何处理这种异常，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理，否则编译不通过。

### 手动抛出异常：throw

  Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。

  throw exceptionObject

**throws和throw的区别:**

 throw是语句抛出一个异常。
         语法：throw (异常对象);
           throw e;

  throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)
                语法：[(修饰符)](返回值类型)(方法名)([参数列表])[throws(异常类)]{......}
                    public void doA(int a) throws Exception1,Exception3{......}

   throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。

   throws出现在方法函数头，表示在抛出异常，由该方法的调用者来处理。

  throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。

  throw是具体向外抛异常的动作，所以它是抛出一个异常实例。

 throws说明你有那个可能，倾向。

 throw的话，那就是你把那个倾向变成真实的了。

### 异常的链化

  在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常，但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。

异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫它根源异常（cause）。

### 自定义异常

   如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。

按照国际惯例，自定义的异常应该总是包含如下的构造函数：

​				一个无参构造函数

​        	   一个带有String参数的构造函数，并传递给父类的构造函数。

​                一个带有String参数和Throwable参数，并都传递给父类构造函数。

​                一个带有Throwable 参数的构造函数，并传递给父类的构造函数。


### 异常的注意事项

   1、当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。

例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。

 2、Java程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。

也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。

**一个不容易理解的事实：在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。**

**finally中的return 会覆盖 try 或者catch中的返回值。**

**finally中的return会抑制（消灭）前面try或者catch块中的异常**

**finally中的异常会覆盖（消灭）前面try或者catch中的异常**

个人建议：

   不要在fianlly中使用return。

不要在finally中抛出异常。

  减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。

  将尽量将所有的return写在函数的最后面，而不是try ... catch ... finally中。

## 21、java中 IO流分为几种

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

所有流的基类

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20190706132956362.png)

## 22、BIO、NIO、AIO 有什么区别？

**同步**是指发出一个请求，在没有得到结果之前该请求就不返回结果，请求返回时，也就得到结果了。

**异步**是指发出一个请求后，立刻得到了回应，但没有返回结果。这时我们可以再处理别的事情(发送其他请求)，所以这种方式需要我们通过状态主动查看是否有了结果, 或者可以设置一个回调来通知调用者。

**阻塞**是指请求结果返回之前，当前线程会被挂起(被阻塞)，这时线程什么也做不了

**非阻塞**是指请求结果返回之前，当前线程没有被阻塞，仍然可以做其他事情。

BIO 就是传统的 java.io包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。

NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。

AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它AIO（Asynchronous IO），异步 IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200727100928591.png)

程序发送请求给内核，然后由内核去进行通信，在内核准备好数据之前这个线程是被挂起的，所以在两个阶段程序都处于挂起状态。

- BIO的特点就是在IO执行的两个阶段都被block了

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200727101055587.png)

与BIO的明显区别是，发起第一次请求后，线程并没有被阻塞，它反复检查数据是否准备好，把原来大块不能用的阻塞时间分成了许多“小阻塞”(检查)，所以进程不断有机会被执行。这个检查有没有准备好数据的过程有点类似于“轮询”。

- NIO的特点就是程序需要不断的主动询问内核数据是否准备好。第一个阶段非阻塞，第二个阶段阻塞

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20200727101800945.png)

**AIO**属于异步模型， 用户线程可以同时处理别的事情，我们怎么进一步加工处理结果呢? Java在这个模型中提供了两种方法：

一种是基于”回调”，我们可以实现**CompletionHandler**接口，在调用时把回调函数传递给对应的API即可

另一种是返回一个**Future**。处理完别的事情，可以通过**isDone()** 可查看是否已经准备好数据，通过get()方法等待返回数据。

上面这几种模式，**BIO**整个过程都等待返回，**NIO**和**IO多路复用**在第二个阶段等待返回，因此从整个过程来看，这三个模式都属于同步方式。 **AIO**在整个过程中没有等待返回，属于异步方式。

##  23、动态代理是什么？有哪些应用？

动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。

动态代理实现：首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。

动态代理的应用：Spring的AOP，加事务，加权限，加日志。

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/7c280502a9394b5f90f659442310603c.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20181228090858878.png)

在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。

（1）和静态代理相同，首先定义一个person接口

```java
public interface Person {

	//租房
	public void rentHouse();
}

```

（2）创建被代理的类

```java
public class Renter implements Person{

	@Override
	public void rentHouse() {
		System.out.println("租客租房成功！");
		
	}

}

```

（3）创建RenterInvocationHandler类，这个类实现了InvocationHandler接口，并持有一个被代理类的对象，InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。然后通过反射在invoke方法中执行代理类的方法。在代理过程中，在执行代理类的方法前或者后可以执行自己的操作，这就是spring aop的主要原理。


```java
public class RenterInvocationHandler<T> implements InvocationHandler{
	//被代理类的对象
	private T target;
	
	public RenterInvocationHandler(T target){
		this.target = target;
	}

	/**
     * proxy:代表动态代理对象
     * method：代表正在执行的方法
     * args：代表调用目标方法时传入的实参
     */
	@Override
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		//代理过程中插入其他操作
		System.out.println("租客和中介交流");
		Object result = method.invoke(target, args);
		return result;
	}

}

```

（4）创建动态代理对象

```java
public class ProxyTest {

	public static void main(String[] args) {

		//创建被代理的实例对象
		Person renter = new Renter();
		//创建InvocationHandler对象
		InvocationHandler renterHandler = new RenterInvocationHandler<Person>(renter);
		
		
		//创建代理对象,代理对象的每个执行方法都会替换执行Invocation中的invoke方法
		Person renterProxy = (Person)Proxy.newProxyInstance(Person.class.getClassLoader(),new Class<?>[]{Person.class}, renterHandler);
		renterProxy.rentHouse();
		
		//也可以使用下面的方式创建代理类对象，Proxy.newProxyInstance其实就是对下面代码的封装
		/*try {
			//使用Proxy类的getProxyClass静态方法生成一个动态代理类renterProxy 
			Class<?> renterProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class<?>[]{Person.class});
			//获取代理类renterProxy的构造器，参数为InvocationHandler
			Constructor<?> constructor = renterProxyClass.getConstructor(InvocationHandler.class);
			//使用构造器创建一个代理类实例对象
			Person renterProxy = (Person)constructor.newInstance(renterHandler);
			renterProxy.rentHouse();
			//
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}*/
	}

}

```

## 24、Java的深拷贝与浅拷贝的区别

浅拷贝：在拷贝一个对象时，对对象的基本数据类型的成员变量进行拷贝，但对引用类型的成员变量只进行引用的传递，并没有创建一个新的对象，当对引用类型的内容修改会影响被拷贝的对象。

深拷贝：在拷贝一个对象时，除了对基本数据类型的成员变量进行拷贝，对引用类型的成员变量进行拷贝时，创建一个新的对象来保存引用类型的成员变量。

## 25、String是否是基本的数据类型？

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20180718214014327)

String不是基本的数据类型，是final修饰的java类，是引用类型。因此不可以继承这个类、不能修改这个类。