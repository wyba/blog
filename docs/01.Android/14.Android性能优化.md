---
title: Android性能优化
date: 2022-04-22 16:35:57
permalink: /pages/066351/
categories:
  - Android
tags:
  - 性能优化
---

> 说明：性能优化，老生常淡了

安卓开发大军浩浩荡荡，经过近十年的发展，Android技术优化日异月新，如今Android 9.0 已经发布，Android系统性能也已经非常流畅，可以在体验上完全媲美iOS。
但是，到了各大厂商手里，改源码、自定义系统，使得Android原生系统变得鱼龙混杂，然后到了不同层次的开发工程师手里，因为技术水平的参差不齐，即使很多手机在跑分软件性能非常高，打开应用依然存在卡顿现象。另外，随着产品内容迭代，功能越来越复杂，UI页面也越来越丰富，也成为流畅运行的一种阻碍。综上所述，对APP进行性能优化已成为开发者该有的一种综合素质，也是开发者能够完成高质量应用程序作品的保证。

在Android应用优化方面，我们主要从以下4个方面进行优化：

1.稳定（内存溢出、崩溃）
2.流畅（卡顿）
3.耗损（耗电、流量、网络）
4.安装包（APK瘦身）

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/4118241-fbeaa6abd09fecd4.png)

## 一、内存优化

在Android应用开发中，影响稳定性的原因很多，比如内存使用不合理、代码异常场景考虑不周全、代码逻辑不合理等，都会对应用的稳定性造成影响。
其中最常见的两个场景是：Crash 和 ANR，这两个错误将会使得程序无法使用。所以做好Crash监控，把崩溃信息、异常信息收集记录起来，以便后续分析；合理使用主线程处理业务，不要在主线程中做耗时操作，防止ANR程序无响应发生。

通俗来讲，内存泄露不仅仅会造成应用内存占用过大，还会导致应用卡顿，造成不好的用户体验。

内存抖动
 短时间内创建了大量对象同时又被快速释放。比如在一个大循环里去不断创建对象，会导致频繁gc;

内存泄漏
 内存泄漏会导致可用内存逐渐变少，而且内存碎片加多，这也会增多gc次数，甚至可能发生OOM

一次申请太大内存空间
 由于内存碎片的存在，就算内存本身足够，但由于碎片导致无法找到一块大空间，这也会触发gc；

内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了没来就不多的内存空间。

那么什么情况下会出现这样的对象呢？ 基本可以分为以下四大类：
 1、集合类泄漏
 2、单例/静态变量造成的内存泄漏
 3、匿名内部类/非静态内部类
 4、资源未关闭造成的内存泄漏

集合类添加元素后，仍引用着集合元素对象，导致该集合中的元素对象无法被回收，从而导致内存泄露。

当我们在Activity里面使用这个的时候，把我们Acitivty的context传进去，那么，这个单例就持有这个Activity的引用，当这个Activity没有用了，需要销毁的时候，因为这个单例还持有Activity的引用，所以无法GC回收，所以就出现了内存泄漏，也就是生命周期长的持有了生命周期短的引用，造成了内存泄漏。

非静态内部类他会持有他外部类的引用，从图我们可以看到非静态内部类的生命周期可能比外部类更长，这就是二楼的情况一致了，如果非静态内部类的周明周期长于外部类，在加上自动持有外部类的强引用，我的乖乖，想不泄漏都难啊。

引用分为强引用，软引用，弱引用，虚引用，强度依次递减。

- 强引用
   我们平时不做特殊处理的一般都是强引用，如果一个对象具有强引用，GC宁可OOM也绝不会回收它。看出多强硬了吧。
- 软引用(SoftReference)
   如果内存空间足够，GC就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
- 弱引用（WeakReference）
   弱引用要比软引用,更弱一个级别，内存不够要回收他，GC的时候不管内存够不够也要回收他，简直是弱的一匹。不过GC是一个优先级很低的线程，也不是太频繁进行，所以弱引用的生活还过得去，没那么提心吊胆。
- 虚引用
   用的甚少，我没有用过，如果想了解的朋友，可以自行谷歌百度。

所以我们用弱引用来修饰Activity，这样GC的时候，该回收的也就回收了，不会再有内存泄漏了。很完美。

资源未关闭造成的内存泄漏

- 网络、文件等流忘记关闭
- 手动注册广播时，退出时忘记 unregisterReceiver()
- Service 执行完后忘记 stopSelf()
- EventBus 等观察者模式的框架忘记手动解除注册

## 二、交互优化

交互是与用户体验最直接的方面，交互场景大概可以分为四个部分：UI 绘制、应用启动、页面跳转、事件响应。对于上面四个方面，大致可以从以下两个方面来进行优化：

界面绘制：主要原因是绘制的层级深、页面复杂、刷新不合理，由于这些原因导致卡顿的场景更多出现在 UI 和启动后的初始界面以及跳转到页面的绘制上。

数据处理：导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，一是数据在处理 UI 线程，二是数据处理占用 CPU 高，导致主线程拿不到时间片，三是内存增加导致 GC 频繁，从而引起卡顿。

我们知道，Android的绘制需要经过onMeasure、onLayout、onDraw等几个步骤，所以布局的层级越深、元素越多、耗时也就越长。还有就是Android 系统每隔 16ms 发出 VSYNC 信号，触发对 UI 进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的 60FPS。如果某个操作花费的时间是 24ms ，系统在得到 VSYNC 信号时就无法正常进行正常渲染，这样就发生了丢帧现象。

之所以出现卡顿现象，是因为有两个原因：

绘制任务太重，绘制一帧内容耗时太长

主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧

### 布局优化

在Android种系统对View进行测量、布局和绘制时，都是通过对View数的遍历来进行操作的。如果一个View数的高度太高就会严重影响测量、布局和绘制的速度。Google也在其API文档中建议View高度不宜哦过10层。现在版本种Google使用RelativeLayout替代LineraLayout作为默认根布局，目的就是降低LineraLayout嵌套产生布局树的高度，从而提高UI渲染的效率。
在布局优化方面，我们可以从以下几个方面进行优化：

布局复用，使用<include>标签重用layout；
提高显示速度，使用<ViewStub>延迟View加载；
减少层级，使用<merge>标签替换父级布局；
注意使用wrap_content，会增加measure计算成本；
删除控件中无用属性；

复杂界面可选择ConstraintLayout，可有效减少层级

尽量减少不必要的嵌套

能用LinearLayout和FrameLayout，就不要用RelativeLayout，因为RelativeLayout控件相对比较复杂，测绘也想要耗时。

### 渲染优化

过度绘制是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构中，如果不可见的 UI 也在做绘制的操作，就会导致某些像素区域被绘制了多次，从而浪费了多余的 CPU 以及 GPU 资源。我们可以通过开启手机的过渡绘制功能来检测页面是否被过度绘制。

为了避免过度绘制，我们可以从以下几个方面进行优化：

布局上的优化，移除 XML 中非必须的背景，移除 Window 默认的背景、按需显示占位背景图片。
自定义View优化，使用 canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。

- onDraw中不要创建新的局部对象
- onDraw方法中不要做耗时的任务

### 启动优化

app启动分为冷启动（Cold start）、热启动（Hot start）和温启动（Warm start）三种。

应用一般都有闪屏页，优化闪屏页的 UI 布局，可以通过 Profile GPU Rendering 检测丢帧情况。

也可以通过启动加载逻辑优化。可以采用分布加载、异步加载、延期加载策略来提高应用启动速度。

数据准备。数据初始化分析，加载数据可以考虑用线程初始化等策略。

1、利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；
 2、避免在启动时做密集沉重的初始化（Heavy app initialization）；
 3、避免I/O操作、反序列化、网络操作、布局嵌套等。

### 刷新优化

item 刷新
 对于列表的中的item的操作，比如对item点赞，此时不应该让整个列表刷新，而是应该只刷新这个item.

复杂Activity刷新
 对于较为复杂的页面，个人建议不要写在一个activity中，建议使用几个fragment进行组装，这样一来，module的变更可以只刷新某一个具体的fragment，而不用整个页面都走刷新逻辑。但是问题来了，fragment之间如何共享数据呢？好，看我怎么操作。

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/4118241-90e3e6642b7ea66f.png)



## 四、APK瘦身

应用安装包大小对应用使用没有影响，但应用的安装包越大，用户下载的门槛越高，特别是在移动网络情况下，用户在下载应用时，对安装包大小的要求更高，因此，减小安装包大小可以让更多用户愿意下载和体验产品。

在Android Studio工具栏里，打开build–>Analyze APK, 选择要分析的APK包 ，可以看到apk的相关信息，如下所示：
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20190618213956249.png)
Android的apk主要有以下信息构成：

assets文件夹。存放一些配置文件、资源文件，assets不会自动生成对应的 ID，而是通过 AssetManager 类的接口获取。

res。res 是 resource 的缩写，这个目录存放资源文件，会自动生成对应的 ID 并映射到 .R 文件中，访问直接使用资源ID。

META-INF。保存应用的签名信息，签名信息可以验证 APK 文件的完整性。

AndroidManifest.xml。这个文件用来描述 Android 应用的配置信息，一些组件的注册信息、可使用权限等。

classes.dex。Dalvik 字节码程序，让 Dalvik 虚拟机可执行，一般情况下，Android 应用在打包时通过Android SDK 中的 dx 工具将 Java 字节码转换为 Dalvik 字节码。

resources.arsc。记录着资源文件和资源 ID 之间的映射关系，用来根据资源 ID 寻找资源。

基于上面的组成部分，那么优化也可以从以下几个方面着手：

代码混淆。使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。

资源优化。比如使用 Android Lint 删除冗余资源，资源文件最少化等。

图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数等。

避免重复功能的库，使用 WebP图片格式等。

插件化，比如功能模块放在服务器上，按需下载，可以减少安装包大小。