---
title: 多进程及IPC
date: 2022-04-28 13:43:43
permalink: /pages/420b54/
categories:
  - Android
tags:
  - 多进程
---

> 进阶

## 一、什么情况需要使用多进程

### 常驻后台任务应用

类似音乐类、跑步健身类、手机管家类等长时间需要在后台运行的应用。这些应用的特点就是，当用户切到别的应用，或者关掉手机屏幕的时候，应用本身的核心模块还在正常运行，提供服务。如果因为手机内存过低，或者是进程重要性降低，导致应用被杀掉，后台服务停止，对于这些应用来说，就是灭顶之灾。合理利用多进程，将核心后台服务模块和其他UI模块进行分离，保证应用能更稳定的提供服务，从而提升用户体验。

### 多模块应用

多进程还有一种非常有用的场景，就是多模块应用。比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。

首先多进程开发能为应用解决了OOM问题，Android对内存的限制是针对于进程的，这个阈值可以是48M、24M、16M等，视机型而定，所以，当我们需要加载大图之类的操作，可以在新的进程中去执行，避免主进程OOM。

多进程不光解决OOM问题，还能更有效、合理的利用内存。我们可以在适当的时候生成新的进程，在不需要的时候及时杀掉，合理分配，提升用户体验。减少系统被杀掉的风险。

多进程还能带来一个好处就是，单一进程崩溃并不影响整体应用的使用。例如我在图片浏览进程打开了一个过大的图片，java heap  申请内存失败，但是不影响我主进程的使用，而且，还能通过监控进程，将这个错误上报给系统，告知他在什么机型、环境下、产生了什么样的Bug，提升用户体验。

## 二、如何开启多进程

在Android中使用多进程只有一种方法，那就是给四大组件(Activity、Service、BroadcastReceiver、ContentProvider)在AndroidManifest中指定android:process属性，除此之外没有其他办法，也就是说我们无法给一个线程或者一个实体类指定其运行时所在的进程。

其实还有另一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程，但是这种方法属于特殊情况，也不是常用的创建多进程的方式，因此我们暂时不考虑这种方式。

私有进程和全局进程

- 进程名以“：”开头的进程属于当前应用的**私有进程**，其他应用的组件不可以和它跑在同一个进程当中
- 不以“：”开头的进程属于**全局进程**，其他应用通过shareUID方式可以和它跑在同一个进程中
- Android会为每个应用分配唯一的一个UID，具有相同UID的应用才能共享数据。

（1）私有进程：android:process=":remote"，以冒号开头，冒号后面的字符串原则上是可以随意指定的。如果我们的包名为“com.biyou.multiprocess”，则实际的进程名 为“com.biyou.multiprocess:remote”。这种设置形式表示该进程为当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中。

（2）全局进程：进程名称不以“:”开头的进程都可以叫全局进程，如android:process=“com.secondProcess”，以小写字母开头，表示运行在一个以这个名字命名的全局进程中，其他应用通过设置相同的ShareUID可以和它跑在同一个进程。

（3）两个应用通过ShareUID运行在同一个进程中是有要求的，就是需要两个应用有相同的UID并且签名也要相同。

**注意：**

（1） 静态成员和单例模式完全失效。

（2） 线程同步机制完全消失：因为不是同一个内存，那么无论是锁对象还是全局类都无法保证线程同步，因为不同进程锁的不是同一个对象。

（3） SharePreference可靠性下降：SharePreference不支持两个进程同时执行写操作，因为会导致数据丢失,因为SharedPreferences底层是通过读写XML文件实现的，并发写显然会出现问题，甚至读/写多可能出问题。

（4） Application会多次创建：系统在创建进程的同时分配独立的虚拟机（即代表会多次创建Application），当一个组件运行在一个新的进程中，由于 系统要创建新的进程同时分配独立的虚拟机，因此就是一个启动应用的过程。既然重新启动则会创建新的Application。

（5）sharepreference数据可能会有误差（sharepreference不允许两个线程同时执行操作，其底层是通过XML文件读写完成）

## 三、Android为什么采用Binder做为IPC机制

**Binder是什么？**

从功能上讲：Binder是一种在Android设备上进行IPC(Inter-Process Communication，进程间通信)的主要方式，主要用来实现跨进程通信。

从代码上讲：Binder是一个类，实现了IBinder接口。

从Android Framwork角度来说，Binder是ServerManager连接各种Manager和ManagerService的桥梁。

**为什么需要Binder？**

进程隔离：为了保证安全性&独立性，一个进程不能直接操作或者访问另一个进程，即Android的进程是相互独立、隔离的

IPC(跨进程通信)：在实际开发中，经常需要进程间的合作、交互和通信

进程空间的分配：

 用户空间：数据不可共享，即不可共享空间

 内核空间：数据可以共享，即空闲空间

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/2020112815241412.png)

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20201129143846438.png)



Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于性能、稳定性和安全性几方面的原因。

首先说说性能上的优势。Socket  作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。

再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。

另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android  平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC  没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC  接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的  UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入  UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC  访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder  既支持实名 Binder，又支持匿名 Binder，安全性高。

![img](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/d495518c826d3892676f1c4ed0933d0c.png)

## 四、IPC常用方式

![image-20220421182731115](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/image-20220421182731115.png)

## 五、AIDL

AIDL - Android Interface Definition Language - Android  接口定义语言。因为在Android中，应用程序运行在各自独立的进程里。应用程序之间是不能访问对方的内存空间的。有时为了实现进程间的通信，要用到PCI机制。Android支持PCI机制，但是需要Android能读懂的序列化数据（marshaling/un marshaling of data）.   AIDL就是为了描述这样的数据产生的，它是一种接口定义语言。语法类似JAVA，.aidl文件里面写的是公布给客户端接口声明。

**1.AIDL介绍**

在Android中，每个应用（Application）执行在它自己的进程中，无法直接调用到其他应用的资源，这也符合“沙箱”的理念。所谓沙箱原理，一般来说用在移动电话业务中，简单地说旨在部分地或全部地隔离应用程序。关于沙箱技术我们这里就不多做介绍了。因此，在Android中，当一个应用被执行时，一些操作是被限制的，比如访问内存，访问传感器，等等。这样做可以最大化地保护系统，免得应用程序“为所欲为”。那我们有时需要在应用间交互，怎么办呢？于是，Android需要实现IPC协议。然而，这个协议还是有点复杂，主要因为需要实现数据管理系统（在进程或线程间传递数据）。Android为我们实现了自己的IPC，也就是AIDL。

**2.定义AIDL接口**

AIDL是IPC的一个轻量级实现，用了对于Java开发者来说很熟悉的语法。Android也提供了一个工具，可以自动创建Stub（类构架，类骨架）。当我们需要在应用间通信时，我们需要按以下几步走：

a. 定义一个AIDL接口

b. 为远程服务（Service）实现对应Stub

c. 将服务“暴露”给客户程序使用

**3.实例解析**

AIDL的语法很类似Java的接口（Interface），只需要定义方法的签名。

AIDL支持的数据类型与Java接口支持的数据类型有些不同

a. 所有基础类型（int, char, 等）

b. String，List，Map，CharSequence等类

c. 其他AIDL接口类型

d. 所有Parcelable的类

**AIDL生成Java文件详细分析**

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/19b904a90e50414bb50d62f7ce868a31.png)

这里Stub就是远程端的具体真实实现，一般在服务端Serivce中实现，而Stub.Proxy类则是主要给客户端提供调用远程端的接口。

Stub: AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部抽象类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的  IInterface 的相关实现需要开发者自己实现。

proxy:Stub 的静态内部类，是一个实现了IMyAidlInterface接口，所以他是一个远程代理对象，可以用于返回给客户端用。当  client 调用 proxy的某个方法的时候，会将参数传到 proxy  中，在通过其持有的远程实际对象，将方法名和参数等都传给远程实际对象，然后就会回调onTransact，对应的方法就会被调用，以此来实现跨进程调用。

![这里写图片描述](https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20180515200154974)