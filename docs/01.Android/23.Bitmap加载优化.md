---
title: Bitmap加载优化
date: 2022-04-28 16:05:51
permalink: /pages/e86925/
categories:
  - Android
tags:
  - Bitmap
---

## 一、drawable和mipmap的区别是什么？

应用图标的图片资源存放在mipmap系列文件夹中，而其余图片存放在drawable系列文件夹中

1、mipmap纹理映射技术会将资源缩放到设备分辨率大小，drawable会将资源缩放到设备匹配的倍数大小

2、官方推荐开发者将位图等资源放在对应dpi的drawable/下，而不是放在mipmap/下。这样各种dpi可直接找到对应资源，减少了mipmap精确适配时需要缩放计算，也不会因为图片缩放导致显示问题

3、高密度系统的设备去使用低密度目录下的图片资源时，会将图片长宽自动放大以去适应高密度的精度，当然图片占用的内存会更大。

## 二、Bitmap内存占用怎么算的？如加载一张1080*1920的图片，内存占用多少？

Bitmap的内存占用的大小是通过：

宽 * 高 * 单位像素所占字节 //1080 * 1920 * 单位像素所占字节(ARGB值不同，占用字节不同)

Bitmap.Config中有四种不同的ARGB： ALPHA_8、RGB_565、ARGB_4444、ARGB_8888

ALPHA_8：每个像素占8位，没有色彩，只有透明度A-8 即10801920(8/8/1024/1024)= 1.98M

RGB_565：每个像素每个像素占16位，没有透明度 5+6+5 = 16 即10801920(16/8/1024/1024) = 3.96M

ARGB_4444：每个像素占16位，4+4+4+4 = 16 即 10801920(16/8/1024/1024) = 3.96M

ARGB_8888：每个像素占32位，8+8+8+8 = 32 即 10801920(32/8/1024/1024) = 7.92M

注意：加载图片所在内存还和图片放置的目录有关系：放在mdpi、xhdpi之下是不一样的。

在320dpi(xhdpi)设备上运行，当图片放置在xhdpi中时，获取图片宽高依然是352 *  484。当图片放置在mdpi中时，获取宽高是 704 *  968，设备是320dpi的设备，当放置在mdpi时，系统认为图片需要放大，xhdpi是mdpi的两倍，所以获取bitmap的宽高放大了两倍。

当图片都放置在xhdpi时，使用320dpi(xhdpi)设备获取图片宽高是352 * 484，当使用480dpi(xxhdpi)设备获取图片宽高位 528 * 726，即在480dpi设备上时，xhdpi下的图片都认为要被放大480/320(3/2)倍。

结论：

1、在同一个设备上，图片放在依次放在由低到高的分辨率目录中(mdpi~xxxhdpi)，图片的 Bitmap 内存的大小不断减小。

2、在同一个分辨率目录中，依次运行在由低到高的分辨率设备上，图片的 Bitmap 的大小不断增加。

所以：如果只使用一套图片时，尽量把图片放到最大分辨率目录中

## 三、系统如何选择drawable进行加载

Android系统中，在加载图片时，会根据系统自身的dpi设备大小优先匹配最近的一个drawable目录，如果当前目录没有找到，则向上查找，一直找到nodpi，如果都没有找到则向下开始查找(肯定能找到，如果找不到编译器就报错了)。如：设备hdpi 则优先找drawable-hdpi目录下的资源，如果没有则向上  xhdpi、xxhdpi、xxxhdpi、nodpi，都没有的话则开始查找mdpi...

## 四、Bitmap导致的OOM如何解决

Android加载大图时极容易产生OOM，采用压缩算法、缓存、软引用、及时对不再使用的bitmap对象recycle释放等方式解决。

通常会有四种压缩方案：

1、质量压缩：

质量压缩通过减少图片色彩度，不会减少图片像素及宽高，所以不会减少加载到内存中所占的内存大小，只会减少图片所占磁盘的存储大小，是一种有损压缩。

2、采样率压缩：

采样率压缩其原理是缩放 bitmap 的尺寸，采样率inSampleSize为1时不变，2时宽高都变为原来的1/2，所占用内存大小就会变为原来的1/4，以此类推。

由于 inSampleSize 只能为 2 的整次幂，所以无法精确控制大小

3、缩放压缩：Matrix矩阵

缩放压缩使用的是通过矩阵对图片进行缩放，缩放后图片的 宽度、高度以及占用的内存都会改变。

4、色彩模式压缩：Options.inPreferredConfig = Bitmap.Config.XXXX

色彩模式压缩后图片的宽高不会产生变化，由于图片的存储格式改变，与 ARGB_8888 相比，每个像素的占用的字节由 8 变为 4 ， 所以图片占用的内存也为原来的一半。

内存缓存：Android SDK中提供了一个LruCache，用于内存缓存。

磁盘缓存：Android SDK中不提供磁盘缓存的类，但google官方推荐的一个叫DiskLruCache算法。

## 五、LRUCache原理

因此LRU(Least Recently  Used)缓存算法便应运而生，LRU是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。

采用LRU算法的缓存有两种：LrhCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。

LruCache是Android 3.1所提供的一个缓存类，所以在Android中可以直接使用LruCache实现内存缓存

LruCache是个泛型类，主要算法原理是把最近使用的对象用强引用（即我们平常使用的对象引用方式）存储在 LinkedHashMap 中。当缓存满时，把最近最少使用的对象从内存中移除，并提供了get和put方法来完成缓存的获取和添加操作。

### LruCache的使用

①设置LruCache缓存的大小，一般为当前进程可用容量的1/8。

 ②重写sizeOf方法，计算出要缓存的每张图片的大小。

### LruCache的实现原理

LruCache的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队尾，即将被淘汰。而最近访问的对象将放在队头，最后被淘汰。

而LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序，使得LinkedHashMap中的<key,value>对按照一定顺序排列起来。

**由此可见LruCache中维护了一个集合LinkedHashMap，该LinkedHashMap是以访问顺序排序的。当调用put()方法时，就会在结合中添加元素，并调用trimToSize()判断缓存是否已满，如果满了就用LinkedHashMap的迭代器删除队尾元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队头。**

## 六、DiskLruCache

LruCache只是管理了内存中图片的存储与释放，如果图片从内存中被移除的话，那么又需要从网络上重新加载一次图片，这显然非常耗时。对此，Google又提供了一套硬盘缓存的解决方案：DiskLruCache(非Google官方编写，但获得官方认证)。

DiskLruCache最大的特点就是持久化存储，所有的缓存以文件的形式存在。在用户进入APP时，它根据日志文件将DiskLruCache恢复到用户上次退出时的情况，日志文件journal保存每个文件的下载、访问和移除的信息，在恢复缓存时逐行读取日志并检查文件来恢复缓存。

