<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java集合 | wyb&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/blog/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="主流技术博客,简洁至上,专注全栈学习与总结。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.7dd69afa.css" as="style"><link rel="preload" href="/blog/assets/js/app.7a0bcda5.js" as="script"><link rel="preload" href="/blog/assets/js/2.a5a0f980.js" as="script"><link rel="preload" href="/blog/assets/js/46.a65e64ce.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.2ffa04b0.js"><link rel="prefetch" href="/blog/assets/js/11.70f92a32.js"><link rel="prefetch" href="/blog/assets/js/12.340f549c.js"><link rel="prefetch" href="/blog/assets/js/13.9e5f7372.js"><link rel="prefetch" href="/blog/assets/js/14.b9340184.js"><link rel="prefetch" href="/blog/assets/js/15.6c1f35df.js"><link rel="prefetch" href="/blog/assets/js/16.e3c6e4ef.js"><link rel="prefetch" href="/blog/assets/js/17.0053c99b.js"><link rel="prefetch" href="/blog/assets/js/18.45a0f3ed.js"><link rel="prefetch" href="/blog/assets/js/19.fb9cc485.js"><link rel="prefetch" href="/blog/assets/js/20.3d5c7a50.js"><link rel="prefetch" href="/blog/assets/js/21.3d0ee275.js"><link rel="prefetch" href="/blog/assets/js/22.e8a9df9a.js"><link rel="prefetch" href="/blog/assets/js/23.82ed3e72.js"><link rel="prefetch" href="/blog/assets/js/24.9d7a7b68.js"><link rel="prefetch" href="/blog/assets/js/25.0bc9ab07.js"><link rel="prefetch" href="/blog/assets/js/26.d2b7a967.js"><link rel="prefetch" href="/blog/assets/js/27.2c02fa2c.js"><link rel="prefetch" href="/blog/assets/js/28.a1afa2d7.js"><link rel="prefetch" href="/blog/assets/js/29.10d9dc2f.js"><link rel="prefetch" href="/blog/assets/js/3.8ec5b007.js"><link rel="prefetch" href="/blog/assets/js/30.425d8100.js"><link rel="prefetch" href="/blog/assets/js/31.63e4f8fb.js"><link rel="prefetch" href="/blog/assets/js/32.77a66ca1.js"><link rel="prefetch" href="/blog/assets/js/33.d0e23080.js"><link rel="prefetch" href="/blog/assets/js/34.1e204563.js"><link rel="prefetch" href="/blog/assets/js/35.2833874a.js"><link rel="prefetch" href="/blog/assets/js/36.97de71b1.js"><link rel="prefetch" href="/blog/assets/js/37.9036f6e9.js"><link rel="prefetch" href="/blog/assets/js/38.6793c03d.js"><link rel="prefetch" href="/blog/assets/js/39.849e03fc.js"><link rel="prefetch" href="/blog/assets/js/4.6e55e017.js"><link rel="prefetch" href="/blog/assets/js/40.56980ac8.js"><link rel="prefetch" href="/blog/assets/js/41.7a196738.js"><link rel="prefetch" href="/blog/assets/js/42.10732ea3.js"><link rel="prefetch" href="/blog/assets/js/43.810ba5a4.js"><link rel="prefetch" href="/blog/assets/js/44.73bbd126.js"><link rel="prefetch" href="/blog/assets/js/45.63b7b5a1.js"><link rel="prefetch" href="/blog/assets/js/47.00dc050a.js"><link rel="prefetch" href="/blog/assets/js/48.b91a0ddd.js"><link rel="prefetch" href="/blog/assets/js/49.4a16d835.js"><link rel="prefetch" href="/blog/assets/js/5.4843dc8e.js"><link rel="prefetch" href="/blog/assets/js/50.132e204b.js"><link rel="prefetch" href="/blog/assets/js/51.1345b9a1.js"><link rel="prefetch" href="/blog/assets/js/52.742ee8db.js"><link rel="prefetch" href="/blog/assets/js/53.8d9c7dd6.js"><link rel="prefetch" href="/blog/assets/js/54.c4038d3f.js"><link rel="prefetch" href="/blog/assets/js/55.766e53e6.js"><link rel="prefetch" href="/blog/assets/js/56.ad60a3d1.js"><link rel="prefetch" href="/blog/assets/js/57.13758d00.js"><link rel="prefetch" href="/blog/assets/js/58.ee3f65e8.js"><link rel="prefetch" href="/blog/assets/js/59.602af4ee.js"><link rel="prefetch" href="/blog/assets/js/6.da76d55e.js"><link rel="prefetch" href="/blog/assets/js/60.15e31058.js"><link rel="prefetch" href="/blog/assets/js/61.7f219b23.js"><link rel="prefetch" href="/blog/assets/js/62.10d98d67.js"><link rel="prefetch" href="/blog/assets/js/63.8ef0d49d.js"><link rel="prefetch" href="/blog/assets/js/64.983ab7ac.js"><link rel="prefetch" href="/blog/assets/js/65.37330ddf.js"><link rel="prefetch" href="/blog/assets/js/66.2776a634.js"><link rel="prefetch" href="/blog/assets/js/67.8b5b3535.js"><link rel="prefetch" href="/blog/assets/js/68.cccc4d3a.js"><link rel="prefetch" href="/blog/assets/js/7.ba6e6c9a.js"><link rel="prefetch" href="/blog/assets/js/8.99b38245.js"><link rel="prefetch" href="/blog/assets/js/9.fc8f51e1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.7dd69afa.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/EB-logo.png" alt="wyb's blog" class="logo"> <span class="site-name can-hide">wyb's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div> <a href="https://github.com/wyba/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/lufei.jpeg"> <div class="blogger-info"><h3>wyb</h3> <span>吾日三省吾身</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div> <a href="https://github.com/wyba/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/java_1/" class="sidebar-link">JDK安装及环境变量设置</a></li><li><a href="/blog/pages/f55250/" class="sidebar-link">HashMap原理和扩容机制</a></li><li><a href="/blog/pages/38975b/" class="sidebar-link">Java反射机制</a></li><li><a href="/blog/pages/fa6c4a/" class="sidebar-link">Java注解</a></li><li><a href="/blog/pages/c91116/" class="sidebar-link">Java泛型</a></li><li><a href="/blog/pages/0f6210/" class="sidebar-link">Java多线程</a></li><li><a href="/blog/pages/131fdc/" class="sidebar-link">Java基础</a></li><li><a href="/blog/pages/f7a5cc/" class="sidebar-link">Java设计模式总结</a></li><li><a href="/blog/pages/3e2d7c/" aria-current="page" class="active sidebar-link">Java集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_1、java-容器都有哪些" class="sidebar-link">1、java 容器都有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_2、collection-和-collections-有什么区别" class="sidebar-link">2、Collection 和 Collections 有什么区别？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_3、list、set、map-之间的区别是什么" class="sidebar-link">3、List、Set、Map 之间的区别是什么？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_4、hashmap-和-hashtable-有什么区别" class="sidebar-link">4、HashMap 和 Hashtable 有什么区别？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_5、说一下-hashmap-的实现原理" class="sidebar-link">5、说一下 HashMap 的实现原理？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#什么是链表" class="sidebar-link">什么是链表</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现" class="sidebar-link">HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#hashmap的put方法的具体流程" class="sidebar-link">HashMap的put方法的具体流程？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#什么是treemap-简介" class="sidebar-link">什么是TreeMap 简介</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#如何决定使用-hashmap-还是-treemap" class="sidebar-link">如何决定使用 HashMap 还是 TreeMap？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#hashmap-和-concurrenthashmap-的区别" class="sidebar-link">HashMap 和 ConcurrentHashMap 的区别</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#concurrenthashmap-和-hashtable-的区别" class="sidebar-link">ConcurrentHashMap 和 Hashtable 的区别？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3e2d7c/#concurrenthashmap-底层具体实现知道吗-实现原理是什么" class="sidebar-link">ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_6、set有哪些实现类" class="sidebar-link">6、set有哪些实现类？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_7、说一下-hashset-的实现原理" class="sidebar-link">7、说一下 HashSet 的实现原理？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_8、arraylist-和-linkedlist-的区别是什么" class="sidebar-link">8、ArrayList 和 LinkedList 的区别是什么？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_9、如何实现数组和-list-之间的转换" class="sidebar-link">9、如何实现数组和 List 之间的转换？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_10、arraylist-和-vector-的区别是什么" class="sidebar-link">10、ArrayList 和 Vector 的区别是什么？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_11、array-和-arraylist-有何区别" class="sidebar-link">11、Array 和 ArrayList 有何区别？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_12、在-queue-中-poll-和-remove-有什么区别" class="sidebar-link">12、在 Queue 中 poll()和 remove()有什么区别？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_13、哪些集合类是线程安全的" class="sidebar-link">13、哪些集合类是线程安全的？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_14、迭代器-iterator-是什么" class="sidebar-link">14、迭代器 Iterator 是什么？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_15、iterator-怎么使用-有什么特点" class="sidebar-link">15、Iterator 怎么使用？有什么特点？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_16、iterator-和-listiterator-有什么区别" class="sidebar-link">16、Iterator 和 ListIterator 有什么区别？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_17、怎么确保一个集合不能被修改" class="sidebar-link">17、怎么确保一个集合不能被修改？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_18、队列和栈是什么-有什么区别" class="sidebar-link">18、队列和栈是什么？有什么区别？</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3e2d7c/#_19、java集合的快速失败机制-fail-fast" class="sidebar-link">19、Java集合的快速失败机制 “fail-fast”？</a></li></ul></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1baff76c><div class="articleInfo" data-v-1baff76c><ul class="breadcrumbs" data-v-1baff76c><li data-v-1baff76c><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-1baff76c></a></li> <li data-v-1baff76c><a href="/blog/Java/#Java" data-v-1baff76c>Java</a></li></ul> <div class="info" data-v-1baff76c><div title="作者" class="author iconfont icon-touxiang" data-v-1baff76c><a href="https://github.com/wyba" target="_blank" title="作者" class="beLink" data-v-1baff76c>wyb</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1baff76c><a href="javascript:;" data-v-1baff76c>2022-04-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Java集合<!----></h1> <div class="page-slot page-slot-top"><!-- 固定100% * 90px可显示，max-height:90px未见显示-->
     <ins class="adsbygoogle"
          style="display:inline-block;width:100%;max-height:90px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6625304284"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="theme-vdoing-content content__default"><blockquote><p>摸索着</p></blockquote> <h2 id="_1、java-容器都有哪些"><a href="#_1、java-容器都有哪些" class="header-anchor">#</a> 1、java 容器都有哪些？</h2> <p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p> <p>Collection集合主要有List和Set两大接口</p> <p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/66ac0908038d45b1a739c9c835b0f072.png" alt="在这里插入图片描述"></p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/724cb00a7ce34cd09d67a35609c53a91.png" alt="在这里插入图片描述"></p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/20210424172014888.png" alt="img"></p> <h2 id="_2、collection-和-collections-有什么区别"><a href="#_2、collection-和-collections-有什么区别" class="header-anchor">#</a> 2、Collection 和 Collections 有什么区别？</h2> <p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p> <p>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p> <h2 id="_3、list、set、map-之间的区别是什么"><a href="#_3、list、set、map-之间的区别是什么" class="header-anchor">#</a> 3、List、Set、Map 之间的区别是什么？</h2> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/56068a29e34750229b3f2527dd172a13.png" alt="在这里插入图片描述"></p> <p>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p> <p>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p> <p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p> <h2 id="_4、hashmap-和-hashtable-有什么区别"><a href="#_4、hashmap-和-hashtable-有什么区别" class="header-anchor">#</a> 4、HashMap 和 Hashtable 有什么区别？</h2> <p><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</p> <p><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</p> <p><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</p> <p><strong>初始容量大小和每次扩充容量大小的不同</strong> ：</p> <p>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p> <p>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</p> <p><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p> <p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p> <h2 id="_5、说一下-hashmap-的实现原理"><a href="#_5、说一下-hashmap-的实现原理" class="header-anchor">#</a> 5、说一下 HashMap 的实现原理？</h2> <p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p> <p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p> <p>HashMap 基于 Hash 算法实现的</p> <p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p> <p>存储时，如果出现hash值相同的key，此时有两种情况。</p> <p>(1)如果key相同，则覆盖原始值；</p> <p>(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p> <p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p> <p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p> <p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p> <h3 id="什么是链表"><a href="#什么是链表" class="header-anchor">#</a> 什么是链表</h3> <p>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。</p> <p>链表大致分为单链表和双向链表</p> <p>单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针</p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/b139c85a637d06ef2dff2305690be56e.png" alt="在这里插入图片描述"></p> <p>双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针</p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/0897ec9d18e4c0b5690a63d8473f37c1.png" alt="在这里插入图片描述"></p> <p>链表的优点</p> <p>（1）插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</p> <p>（2）内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</p> <p>（3）大小没有固定，拓展很灵活。</p> <p>链表的缺点：</p> <ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul> <h3 id="hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现"><a href="#hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现" class="header-anchor">#</a> HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3> <ul><li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；**所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**拉链法</strong>的方式可以解决哈希冲突。</li></ul> <p>HashMap JDK1.8之前</p> <p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p> <p>HashMap JDK1.8之后</p> <p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p> <p>JDK1.8主要解决或优化了一下问题：</p> <ol><li>resize 扩容优化</li> <li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li> <li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/image-20220426141042213.png" alt="image-20220426141042213"></p> <h3 id="hashmap的put方法的具体流程"><a href="#hashmap的put方法的具体流程" class="header-anchor">#</a> HashMap的put方法的具体流程？</h3> <p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/03d380e48d04f767d7c46b1369cad95e.png" alt="在这里插入图片描述"></p> <p>（1）判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p> <p>（2）根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p> <p>（3）判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p> <p>（4）判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</p> <p>（5）遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p> <p>（6）插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p> <h3 id="什么是treemap-简介"><a href="#什么是treemap-简介" class="header-anchor">#</a> 什么是TreeMap 简介</h3> <p>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。</p> <p>TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p> <p>TreeMap是线程非同步的。</p> <h3 id="如何决定使用-hashmap-还是-treemap"><a href="#如何决定使用-hashmap-还是-treemap" class="header-anchor">#</a> 如何决定使用 HashMap 还是 TreeMap？</h3> <p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p> <h3 id="hashmap-和-concurrenthashmap-的区别"><a href="#hashmap-和-concurrenthashmap-的区别" class="header-anchor">#</a> HashMap 和 ConcurrentHashMap 的区别</h3> <p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</p> <p>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p> <h3 id="concurrenthashmap-和-hashtable-的区别"><a href="#concurrenthashmap-和-hashtable-的区别" class="header-anchor">#</a> ConcurrentHashMap 和 Hashtable 的区别？</h3> <p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p> <p>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p> <p><strong>实现线程安全的方式</strong>：</p> <p>在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p> <p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p> <h3 id="concurrenthashmap-底层具体实现知道吗-实现原理是什么"><a href="#concurrenthashmap-底层具体实现知道吗-实现原理是什么" class="header-anchor">#</a> ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3> <p>JDK1.7</p> <p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p> <p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p> <p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/ed519c53b0df4c457eac09bc76c3b8e1.png" alt="在这里插入图片描述"></p> <p>JDK1.8</p> <p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/7baf6beb2c6d44d71c3dfcba529ee5d2.png" alt="在这里插入图片描述"></p> <h2 id="_6、set有哪些实现类"><a href="#_6、set有哪些实现类" class="header-anchor">#</a> 6、set有哪些实现类？</h2> <p>Set集合类似于一个罐子，丢进去的元素没有明显的顺序,所以我们如果要访问Set中的元素的时候就只能通过元素本身来访问，这就是为什么Set集合中的元素不能重复的原因</p> <p>Set集合判断元素是否相等的标准</p> <p>因为Set集合中的元素不能重复，所以Set集合一定实现了某个方法来判断集合元素相等，Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象；</p> <p>Set实现类不同的依据（集合内部排序的方法不同）</p> <p>1.HashSet（排序的依据是元素的HashCode值）</p> <p>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。如果有两个元素通过equals()方法比较返回true，但它们的hashCode()方法返回值不相等，HashSet将会把它们存储在不同的位置，依然可以添加成功。</p> <p>2.LinkedHashSet</p> <p>HashSet还有一个子类LinkedHashSet，LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。</p> <p>3.TreeSet</p> <p>TreeSet是SortedSet接口的实现类，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态,这里说的排序状态不是只输入顺序，而是指TreeSet中的元素通过Comparator（）接口对元素排序以后，元素的排列分先后，有点类似于数组，而不是像Set一样混乱的摆放就像在一个罐子里一样，杂乱无章，因此TreeSet增加了访问第一个、前一个、后一个、最后一个元素的方法，并提供了三个从TreeSet中截取子TreeSet的方法。</p> <p>​    1.Comparator comparator()：如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator；如果TreeSet采用了自然排序，则返回null。</p> <p>2.Object first()：返回集合中的第一个元素。</p> <p>3.Object last()：返回集合中的最后一个元素。</p> <p>4.Object lower(Object e)：返回集合中位于指定元素之前的元素（即小于指定元素的最大元素，参考元素不需要是TreeSet集合里的元素）</p> <p>5.Object higher (Object e)：返回集合中位于指定元素之后的元素（即大于指定元素的最小元素，参考元素不需要是TreeSet集合里的元素）。</p> <p>6.SortedSet subSet(fromElement, toElement)：返回此Set的子集合，范围从fromElement（包含）到toElement（不包含）。</p> <p>7.SortedSet headSet(toElement)：返回此Set的子集，由小于toElement的元素组成。</p> <p>8.SortedSet tailSet(fromElement)：返回此Set的子集，由大于或等于fromElement的元素组成。</p> <p>4.EnumSet:</p> <p>EnumSet是一个专为枚举类设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。</p> <h2 id="_7、说一下-hashset-的实现原理"><a href="#_7、说一下-hashset-的实现原理" class="header-anchor">#</a> 7、说一下 HashSet 的实现原理？</h2> <p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p> <p>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</p> <p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p> <p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p> <p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>
	<span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>hashCode（）与equals（）的相关规定</strong>：</p> <p>如果两个对象相等，则hashcode一定也是相同的</p> <p>两个对象相等,对两个equals方法返回true</p> <p>两个对象有相同的hashcode值，它们也不一定是相等的</p> <p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p> <p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p> <p><strong>==与equals的区别</strong></p> <p>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</p> <p>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</p> <p><strong>HashSet与HashMap的区别</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/wyba/image_store/blog/image-20220426143048368.png" alt="image-20220426143048368"></p> <h2 id="_8、arraylist-和-linkedlist-的区别是什么"><a href="#_8、arraylist-和-linkedlist-的区别是什么" class="header-anchor">#</a> 8、ArrayList 和 LinkedList 的区别是什么？</h2> <p>1.ArrayList]是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous）</p> <p>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p> <p>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p> <h2 id="_9、如何实现数组和-list-之间的转换"><a href="#_9、如何实现数组和-list-之间的转换" class="header-anchor">#</a> 9、如何实现数组和 List 之间的转换？</h2> <ul><li>Array 转 List： Arrays. asList(array) ；</li> <li>List 转 Array：List 的 toArray() 方法。</li></ul> <h2 id="_10、arraylist-和-vector-的区别是什么"><a href="#_10、arraylist-和-vector-的区别是什么" class="header-anchor">#</a> 10、ArrayList 和 Vector 的区别是什么？</h2> <p><strong>同步性</strong>：</p> <p>Vector是线程安全的，也就是说它的方法直线是线程同步的，而ArrayList是线程不安全的，它的方法之间是线程不同步的</p> <p>如果只有一个线程去访问集合那么使用ArrayList，他不考虑线程安全的问题，所以效率会高一些</p> <p>如果是多个线程去访问集合，那么使用Vector</p> <p><strong>数据增长性</strong></p> <p>ArrayList和Vector集合都有一个初始容量的大小，当元素的个数超过存储容量是，就需要增加ArrayList和Vector的存储空间，每次增加不是</p> <p>增加一个而是增加多个，Vector是增加原来的两倍，ArrayList没有明文规定，但是从源码中可以看出增长原来的1.5倍</p> <p>ArrayList和Vector可以设置初始的存储空间的大小，Vector还以设置增长空间大小，而ArrayList不可以。</p> <h2 id="_11、array-和-arraylist-有何区别"><a href="#_11、array-和-arraylist-有何区别" class="header-anchor">#</a> 11、Array 和 ArrayList 有何区别？</h2> <p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p> <p>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p> <p>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p> <p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p> <h2 id="_12、在-queue-中-poll-和-remove-有什么区别"><a href="#_12、在-queue-中-poll-和-remove-有什么区别" class="header-anchor">#</a> 12、在 Queue 中 poll()和 remove()有什么区别？</h2> <ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li> <li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul> <h2 id="_13、哪些集合类是线程安全的"><a href="#_13、哪些集合类是线程安全的" class="header-anchor">#</a> 13、哪些集合类是线程安全的？</h2> <p>Vector，实现List接口，与ArrayList相比几乎相同，但是是线程安全的。底层是数组。</p> <p>Stack，继承Vector类，先进后出。</p> <p>HashTable，实现Map接口，与HashMap几乎完全相同，但是是线程安全的。</p> <p>java.util.concurrent包下的所有集合类，例如：ConcurrentHashMap。</p> <h2 id="_14、迭代器-iterator-是什么"><a href="#_14、迭代器-iterator-是什么" class="header-anchor">#</a> 14、迭代器 Iterator 是什么？</h2> <p>是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦。</p> <h2 id="_15、iterator-怎么使用-有什么特点"><a href="#_15、iterator-怎么使用-有什么特点" class="header-anchor">#</a> 15、Iterator 怎么使用？有什么特点？</h2> <p>使用方法</p> <p>(1)iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第
一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p> <p>(2) 使用next()获得序列中的下一个元素。</p> <p>(3) 使用hasNext()检查序列中是否还有元素。</p> <p>(4) 使用remove()将迭代器新返回的元素删除。</p> <p>Java中的Iterator功能比较简单，并且只能单向移动：</p> <h2 id="_16、iterator-和-listiterator-有什么区别"><a href="#_16、iterator-和-listiterator-有什么区别" class="header-anchor">#</a> 16、Iterator 和 ListIterator 有什么区别？</h2> <p>1、Iterator 可遍历 Set 和 List 集合； ListIterator 只能遍历 List。</p> <p>2、Iterator 只能单向遍历；ListIterator 可双向遍历（向前/后遍历）。</p> <p>3、ListIterator 继承自 Iterator 接口，添加新功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Consumer</span></span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">&quot;remove&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token class-name">E</span> <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">int</span> <span class="token function">previousIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="_17、怎么确保一个集合不能被修改"><a href="#_17、怎么确保一个集合不能被修改" class="header-anchor">#</a> 17、怎么确保一个集合不能被修改？</h2> <p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;x&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> clist <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span> <span class="token function">unmodifiableCollection</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
clist<span class="token punctuation">.</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;y&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行时此行报错</span>
<span class="token class-name">System</span><span class="token punctuation">.</span> out<span class="token punctuation">.</span> <span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_18、队列和栈是什么-有什么区别"><a href="#_18、队列和栈是什么-有什么区别" class="header-anchor">#</a> 18、队列和栈是什么？有什么区别？</h2> <p>1.队列(Queue)：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表</p> <p>2.栈(Stack)：是限定只能在表的一端进行插入和删除操作的线性表</p> <p>区别：</p> <p>（1）操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</p> <p>（2）可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</p> <p>（3）操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</p> <h2 id="_19、java集合的快速失败机制-fail-fast"><a href="#_19、java集合的快速失败机制-fail-fast" class="header-anchor">#</a> 19、Java集合的快速失败机制 “fail-fast”？</h2> <p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p> <p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p> <p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p> <p>解决办法：</p> <p>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</p> <p>使用CopyOnWriteArrayList来替换ArrayList</p></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/wyba/blog/edit/master/docs/02.Java/09.Java集合.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/blog/tags/?tag=%E9%9B%86%E5%90%88" title="标签">#集合</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/05/06, 17:26:02</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/f7a5cc/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Java设计模式总结</div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/f7a5cc/" class="prev">Java设计模式总结</a></span> <!----></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/af8584/"><div>
            BLE开发
            <!----></div></a> <span class="date">04-29</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/8aff38/"><div>
            动画简介
            <!----></div></a> <span class="date">04-29</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/99060e/"><div>
            View工作流程
            <!----></div></a> <span class="date">04-29</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1070096495@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wyba" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2022
    <span>wyb | <a href="https://github.com/wyba/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><span class="close-but">×</span> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;max-width:160px;max-height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"><div></div></div></div>
    <script src="/blog/assets/js/app.7a0bcda5.js" defer></script><script src="/blog/assets/js/2.a5a0f980.js" defer></script><script src="/blog/assets/js/46.a65e64ce.js" defer></script>
  </body>
</html>
